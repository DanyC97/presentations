Gopher Puzzlers
Golang Paris
11 Oct 2016

Dave Cheney
dave@cheney.net
http://dave.cheney.net/
@davecheney

* Who's read this book?

.image gopher-puzzlers/java-puzzlers.jpg 461 _ 

* Gopher Puzzlers

How well do you know Go?

Hopefully this little quiz will surprise you, and maybe teach you something you didn't know about Go.

* Maps

# https://twitter.com/davecheney/status/364215899340804096

Does this program compile?

.play gopher-puzzlers/maps.go

If it does, what does it print?

* time.Duration

`time.Duration` is defined to be an `int64`

 package time
 
 type Duration int64

What would happen if it was defined to be a `uint64`?

# https://twitter.com/davecheney/status/444707522591477760

* time.Duration (solution)

If `time.Duration` was `uint64` then you could not write.

.play gopher-puzzlers/duration.go

* Space packing

# https://twitter.com/davecheney/status/652278214195187712 

How how much space do values of type `T` consume?

.play gopher-puzzlers/space-packing.go

_Hint_: if you said `4` or `8`, you'd be wrong.

* Space packing (solution)

For 32 bit platforms, the answer is 8.

For 64 bit platforms, the answer is 16.

Rearrange the file

.play gopher-puzzlers/space-packing-ii.go

* The size of things

In this program, the size of variables of type `X` and `Y` in memory varies by platform.

.play gopher-puzzlers/size-of-things.go

By changing _only_one_line_ can you ensure that variables of type x, and y always consume 16 bytes on all platforms that Go 1.7 supports?

* The size of things (cont.)

The solution involves setting n to 4 on 32 bit platforms, and 2 on 64 bit using a constant expression.

.play gopher-puzzlers/size-of-things-ii.go /START OMIT/,/END OMIT/

^uint(0) gives you a number whose bits are all 1, then >> 63 shifts the number 63 binary places to the right. If we’re on a 64 bit platform, this evaluates to 1, shifting 4 one place to the right leaves 2, otherwise 32 ones shifted 63 places to the right gives zero, and 4 shifted right zero times is still 4.

But there is an _even_smaller_ way to write this, can you guess?

* The size of things (cont.)

Credit: Paul Hankin

.play gopher-puzzlers/size-of-things-iii.go /START OMIT/,/END OMIT/

Question: If I change the first `const` to a `var`, will this code compile? Why/Why not?

* Which is faster

Which of these two benchmarks is faster?

.code gopher-puzzlers/which-is-faster.go /START OMIT/,/END OMIT/

* Which is faster (solution)

It's a trap, they're both the same speed (at least in Go 1.7).

However, if we reorganise the functions, they will reverse themselves.

.code gopher-puzzlers/which-is-faster.go /START OMIT/,/END OMIT/

_Lesson_: Modern processors are very sensitive to code layout and alignment. When you're down in the `ns`, little things like this can make a difference.

TODO: show ASM to prove they are the same.

* Named and unnamed

TODO: rename to "assignment"

Does this code compile ?

.play gopher-puzzlers/named-and-unnamed.go /START OMIT/,/END OMIT/

- Yes - Why ?
- No - Why not ?

* Named and unnamed (cont.)

Yes, it does compile.

* Named and unnamed (cont.)

Why is this even a thing ?

Well, if it wasn't, then you wouldn't be able to write things like

 type stack []uintptr
 var st stack = make([]uintptr, 20)

* Named and unnamed (cont.)

There is a bigger point here, unamed types are _very_ common in Go. We almost don't see them they are that common.

You'd expect this to not compile

 type TING int
 
 func Blort(t TING) {}
 
 func main() {
         var i int = 200
         Blort(i)
 }

But would you expect this to compile?

 type TING int
 
 func Blort(t TING) {}
 
 func main() {
         Blort(200)
 }

* Two hundred

What does this program print ?

.play gopher-puzzlers/twohundred.go /START OMIT/,/END OMIT/

* Snowman or poop

On _Linux_ what will this program print ?

.code gopher-puzzlers/snowman-or-poop.go /START OMIT/,/END OMIT/

* Snowman or poop (cont.)

`os.Pipe` calls `pipe(2)` and returns two `*os.File` values. We called them `r` for reader and `w` for writer, but in truth they are bi-directional.

If either end can be a reader _and_ a writer _and_ a closer, why does it matter which end calls close ?

.link https://github.com/golang/go/issues/10001

* Snowman or poop (cont.)

It gets worse. Closing an fd returns it to the processes table of free file descriptors. Suddenly that read(2) on fd 7 is reading a different fd.

.link http://man7.org/linux/man-pages/man2/close.2.html#NOTES

* Snowman or poop (cont.)

Question: Why is it important to sleep for a short time before `r.Close()` ?

Question: Why is it important to call `w.Close()` ? What could happen if we don't ?

* Missing panic

This program prints a panic message to the screen.

.play gopher-puzzlers/missing-panic.go

Without using `recover`, can you suppress the panic message?

* Missing panic (solution)

.play gopher-puzzlers/missing-panic2.go

* Missing panic (cont.)

What's going on here.

- fd 2 is considered by the runtime to be stderr, panic messages are written to it. TODO(dfc) add link to runtime code

- fd 2 is initalised as os.Stderr by the os package. TODO(dfc) code sample and link to os code

- If we close os.Stderr, file descriptior 2 is now closed so the write of the panic message

* Missing panic (cont.)

This is something that cannot be fixed without breaking backward compat.

- Maybe `os.Stderr` should not be a `*os.File`.

- Probably still has to retain a `Close` method.

- You can redirect panic messages to another location by replacing fd 2.

- Probably not a serious problem, you can do this in almost every language.
- Someone replacing

* Panicing mutex

What happens when mutex unlock panics, https://github.com/golang/go/issues/13879.

* Semaphores

Two different ways of implementing a semaphore

Why

What's the difference. 

* Keywords 

Which of these three functions will not compile

func A(string string) string {
    return string+string
    }

func B(l len) int

func C(val, default string) string {
    If val == " 

/// ...

* Declarations

Which of the following are valid declarations?

.code gopher-puzzlers/declarations.go 

* Declarations (solution)

There are two invalid declarations

`import` is a valid declaration, but it must directly follow `package`.

`func` cannot be used in this form because of the ambiguitity with the method syntax.

* Package names

Which of these is a valid package name?

.code gopher-puzzlers/hmm.go

.code gopher-puzzlers/hmm-ii.go

.code gopher-puzzlers/hmm-iii.go

.code gopher-puzzlers/hmm-iv.go

* Packages names (solution)

Package names must be valid [[https://golang.org/ref/spec#identifier][_identifiers_]].

.code gopher-puzzlers/hmm.go

`ಠ` is a _letter_, underscore is also considered a letter.

.code gopher-puzzlers/hmm-ii.go

`100` is a _number_, which is allowed, but identifers _must_ start with a _letter_.

.code gopher-puzzlers/hmm-iii.go

`ಠ` is a _letter_, `~` is _not_ a letter.

.code gopher-puzzlers/hmm-iv.go

`すし` is an identifier, it's Japanese for _sushi_.

* Why isn't Len a method on a slice?

Stylistic 

Also it would mean that an unnamed type had a method, which wouod mean a receiver with an unnamed type. 

Worse a named slice type wouod not have a Len method. 

* Size classes

.code gopher-puzzlers/sizeclass.go

What will this code print?

* Size classes (cont.)

Everyone knows that slices are grown by doubling, but why is the cap 2048?

Several things

- Doubling a 1kb slice to 2kb wastes a lot of space

* One, Two, Three

.play gopher-puzzlers/one-two-three.go /START OMIT/,/END OMIT/

What does this program print? Why? Will it always?

# * FD closing behind the scenes. 


Simplicity and collaboration
Closing Keynote, Gophercon India
21 Feb 2015

Dave Cheney
dave@cheney.net
http://dave.cheney.net/
@davecheney

* Opening

# (5 minutes)

# Hello, my name is Dave. I'm a programmer and Go contributor from Sydney, Australia.

# It is my honor to be your final speaker for today.

# After the priviledge of listening to the presentations from my fellow speakers, I find myself in the inenviable position of not repeating anything that they have already said.

# I'm lucky that I get to program in Go for my day job, and in my spare time, well, that's pretty much dedicated to Go as well.

# I've been involved in porting Go to several new platforms, I've written and spoken a lot about Go performance, but, and I hope this is not a dissapointment for you, I'm not going to speak about any of those topics today.

* Thesis

# I want to open my presentation with a proposion.

.image simplicity/thesis.png _ 800

# Being passionate about Go means being passionate about language advocacy, and a natural hazzard of dwelling too long on the nature of programming results in statements like these.

# But underlying the pithy form enforced by a tweet, I believe there is a gem of truth. I cannot think of a language introduced in my life time that didn't purport to be simple. Each new language offer as a justification, and an enticement, they're inherent simplicity.

# On the other hand, I cannot point to a language introduced in the same time frame with the rallying call of complexity; more complexity than its contemporaries -- but many instead claim to be powerful.

# The idea of proposing a language which offered higher levels of inherent complexity is clearly laughable, yet this what so many contemporary languages have become; complicated, baroque, messes that provide the justification for their own replacement.

# So, every language starts out with simplicity as a goal, yet many of them fail to achieve this goal. Eventually falling back on notions of expressiveness or power of the language as justification for a failure to remain simple.

# Clumsy syntax and non orthogonality, is justified by the inherent complexity of capturing neuanced corner cases of the language, many of them self inflicted by years of careless feature creap.

# Any why is this ? Why do so many language, launched with sincere, idealistic goals, fall afoul of their own self inflicted complexity ?

# One reason, one major reason, I believe, is that to be thought successful, a language should include, somehow, all the popular features of its prdecessors.

* Quote

"Those who cannot remember the past are condemned to repeat it." -- George Santayana

.image simplicity/history.jpg _ 800

# If you would listen to language critics, they demand that any new language should push forward the boundaries of language theory.

# But really this appears to be a veiled request that your, new, language include all the bits they felt were important in their favorite old language, while still holding true to the promise of whatever it was that drew them to your new language I the first place.

# "I want a language that is simple, but incoporates a full Hindley–Milner type system."

# // TODO more examples

# I believe that this is a fundamentally incorrect view.

# Why would a new language be proposed if not to address limitations of it’s predecessors?

# Why should a new language not aim to represent a refinement of the cornucopia of features presented in existing languages, leaning from it's predecessors, rather than repeating their folly.

# Language design is about trade offs, you cannot have your cake and eat it too. Must simplicity be abandoned to deliver a complete programming language ?

# So I challenge the notion that every main stream language must be a superset of those it seeks to replace.

* Simplicity

# (10 minutes)

# This brings me back to my tweet. Go is a language that chooses to be simple, and it does so by choosing to not include many features that other programming languages have acustomed their users to believing are essential.

# So the subtext of this thesis would be; what makes Go successful is what has been left out of the language, just as much as what has been included. Or as Rob Pike put it, "less is exponentially more".

* Simplicity cannot be added later

.image simplicity/16.gif 450 _

You cannot add simplicity after the fact.

# When raising a new building, engineers first sink long foundations, down to the bedrock to provide a stable foundation for the structure of the building. To not do this, to just tamp the area flat, lay a concrete slab and start construction, would leave the building vulnerable to small disturbances from changes in the local area, at risk from rising damp or subsitence due to changes in environmental conditions.

# As programmers, we can recognise this as the parable of leaky abstraction. Just as tall buildings can only be successfully constructed by placing them on a firm foundation, large programs can not be successful if they are placed upon a loose covering of dirt that masks decades of accumulated debris.

# you cannot add simplicity after the fact -- simplicity is only gained by taking things away

* Simplicity is not easy

# Simplicity does not necessarily mean “easy”, but it may mean “straight forward” or uncomplicated. 

# Something which is simple may take a little longer, but it will be reliable.

# Putting this into the context of programming langauges. A simple programming language may choose to limit the number of semantic conveniences it offers to experienced programmers to avoid alienating newcomers.

# As I said above

Simplicity is not a synonym for "easy", nor is achieving a design which is simple an easy task.

* Don’t mistake simple for “crude”

.image simplicity/10_ck_chef_hand_10.jpg _ 800

# Just because something may be simple, don't mistake it for crude.

# While lasers are fabulous technology used in medicine and manufacturing, a chef would always prefer a knife to prepare food, an activity much more fundamental, and far more common place.

# Compared to the laser, a simple chefs knife may appear unsophisticated, but it represents generations of knowledge in metalergy, manufacturing and usability.

* Simplicity is a goal, not a by product

# You should design your programs with simplicty as a goal, not aim to be pleasently surprised when your solution happens to be simple.

"nothing went in [to the language], until all three of us [Ken, Robert and myself], agreed that it was a good idea." -- Rob Pike (Gophercon 2014)

# A Rob Pike noted at Gophercon last year that Go was not designed by committee. The choices in the language represented a distilation of the experiences of Robert Griesemer, Ken Thompson, and himself, and only once they were all conveninced of the features' utility to the language.

* Complexity

# A lack of simplicity is, of course complexity.

.image simplicity/four_string_braid.jpg

Complexity is friction, a force which acts against getting things done.

* Choose simplicity over completeness. 

# There is an exponential cost in completeness.

# The 90% solution, one that remains orthogonal while recognising some things are not possible, vs a language attempting to offer 100% of its capabilities to every possible permutation will be inherently less complex, because as we engineers know,

The last 10% costs another 90% of the effort.

* Good programmers write simple programs

Good programmers write simple programs. 

# They bring their experience, their knowledge and their failures to new designs, to learn from and avoid mistakes in the future.

Do you have what it takes to write a simple program, or will you settle for a powerful program ?

* Simplicity, conclusion

# To steal a quote form Rich Hickey

"Simplicity is the ultimate sophistication" -- Leonardo da Vinci

# Go is a language designed to be simple. It is a feature, not a by product, or an accident. This design for simplicity is woven through every aspect of the language.

* Collaboration

# (10 minutes)

# I hope by now I have convinced you that a need for simplicity in programming langauges, if not many aspects of life, is self evident.

# But there is more than just being simple which is a definition attribute of the success of Go, and this is the realisation that for a programming language to be successful, it must coexist inside a larger community.

# Is programming and art or a science ? Are we artists or engineers ? While this one question is a debate in itself, I hope you will agree with me that as professionals, programming is a little of both; we are both software artists, and software engineers -- and as engineers work as a team. 

* A language for collaboration

Large programs are written by large teams

# I don't believe this is a contraversial statement. 

# The inverse is also true

Large teams of programmers, by their nature, produce large code bases.

# Projects with large goals will necesitate large teams, and thus their output will be comensurate.

# This is the nature of our work.

# Go is a langauge explicity designed for collaboration

* Big problems 

// TODO need image

# Go is a small language, but it is unashamadly a language intended to be used on big projects.

# Small annoyances such as a lack of warnings; only errors, a refusal to allow unused imports, or unused local variables, are all facets of choices designed to help Go work well for large teams of software developers.

# This does not mean that Go is not suitable for the single developer working alone, or a small program written for a specific need, but speaks to the fact that a number of the choices within the language are aimed at growing software teams, and their needs.

# Ultimately Go is a language for the problems that exist in todays commercial programming, not language theory.

* Programming languages as part of an environment

# It may appear heretical to suggest this, as many of the metrics that we as professional software developers are judged by; lines of code written, changed or deleted; the number of revisions committed to source control, etc.

# Writing a program, or more accurately solving a problem; delivering a solution, has little to do with the final act of entering the program into the computer.

# Programs are designed, written, debugged and distributed in an environment signficantly larger than one programmer's editor.

* Code is written to be decoded

.image simplicity/cover-big.jpg 550 _

# The author Peter Siebel suggests that programs are not read, but decoded.

# In hindsight this should have been obvious, after all we call it 'source code', not 'source literature'.

# The program is _encoded_ into an intermediary form that is somewhere between our concept and the computer's executable notation.

# As with many transformations, this encoding of the source program is not lossless; some loss of fidelity, some abiguity, some imprecision is present. This is why others reading source code must _decode_ it, to divine the original intention of the programmer.

# Many of the choices relating to the the way Go code is represented as source speak to this impedence mismatch. The simplicy and regularity of the gramar, while providing few opportunities for individuality, in turn makes it easier for a new reader to decode any Go program and determine its function.

# In fact the language is so regular that the few small conveniences included, like the for range syntax, become gotchas. Non obvious syntactic differnces that require a rule to be memorised for their safe usage.

* How to build a Go community

Pro tip: it starts with

# Go is a language designed from the beginning to be transposed, transformed and processed, at the source level, by tools which are not restricted to the compiler. This has opened up fields of analysis and code generation to the wider Go community.

# While these tools are impressive, I believe the regular syntax of a Go source file belies its greatest champion;

    go fmt

# What is so important about go fmt, and why is it important to go fmt your source code ?

# Part of the reason is to avoid needless debate. Large teams will, by their nature have a wide spectrum of views on many aspects of programming, and source code formatting is the most pernitious.

# Go is a language for collaboration. So, in a large team, just as in a wider community, personal choices are moderated for a harmoneous society.

# The outcome is that nearly all go code is go formatted by convention. Adherence to this convention is an indicator of alignment with the values of Go.

# This is important because it is a social convention leading to positive reinforcement, which is far more powerful than negative reinforcement via a chafing edict from the compiler writer.

# In fact, code that is not well formatted can be a first order indicator of the suitability of the package. 

# Now, I'm not trying to say that poorly formatted code is buggy, but poorly formatted code may be an indication that the authors have not understood the design principials that underscore Go.

# Buggy code can be fixed, but design issues or impedencene mismatches can be much harder to address, especially after it is integrated into your program.

* Batteries included

# As Go programmers we can pick up any piece of Go writen by anyone in the world and start to read it. This goes deeper than just formatting. 

# Go lacks heavy libraries like Boost. There are no qt base classes, no Gobject. There is no preprocessor to obfuscate. Domain specific language rarely appear in Go code.

# The inclusion of maps and slices in the language side steps the most basic interoperability issues you have when working with C or Java code bases. All Go code uses these basic building blocks, so all Go code is accessible to a reader who is versed in the language, not some quaint organisation specfic dialect.

* Interfaces, the UNIX way

# In 1964 Doug McIlroy postulated about the power of pipes for composing programs. This was five years before the first Unix was written mind you.

.image simplicity/pipe.png 700 _

# [ https://twitter.com/jmoiron/status/532314843689132032 ]

# In the last few decades programmers have lost the ability to compose programs, lost behind waves of run time dependencies and brittle type heriarchies that degrade the ability to move quickly and experiment cheaply. 

# Go packages interact with one another via interfaces. Programs are composed, just like the UNIX shell, by combining packages together.

# I can use fmt.Fprintf to write formatted output to a network connection, or a zip file, or writer which discards its input. Coversely I can create a gzip reader that consumes data from a http connection, or a string constant. 

# All of these permutations are possible, in McIlroy's vision, without any of the components having the slightest bit of knowledge about the other parts of the processing chain.

# io.Reader and io.Writer have became architecture that connects between components that deal with streams of bytes. What interfaces can you design that work with different values ?

* Small interfaces

# Interfaces in Go are a unifying force; they are _the_ means of describing behaviour. Interfaces let programmers describe what their package does, not _how_ it does it.

Well designed interfaces are more likely to be small interfaces; the prevailing idiom are interfaces with a single method.

# Compare this to other languages, say Java which has both interface types and abstract classes, or C++ which only has the latter. 

# In those langauges interfaces are generally larger, in terms of the method count required to satsify them, and more complex because of their entanglement with the inhertence based nature of those languages. 

# Interfaces in Go share none of those restrictions and so are simpler, and more powerful. 

Small interfaces lead to simple implementations.

Simple implementations connected by well defined interfaces. 

* Error handling without exceptions

# I've written a lot on the subject of Go's error handling, so I'll restrict my comments to the area of collaboration.

# Java was the only main stream language to attempt to make exceptions checked, to make them part of the method's signature. The rational by Gosling at the time was sound. Looking at the history of unchecked exceptions in languages that existed in the early 1990's, which was basically C++, the difficulty using libraries that relied on exceptions for error handling was clear.

# However it is clear by modern standards that checked exceptions, however well intentioned, are an evolutionary dead end. In fact, modern C++ not only still has not introduced checked exceptions, but has instead introduced a keyword to indicate that a method will never throw an exception.

# So, if exceptions were to be used in any new language they will be of an unchecked variety.

# What a waste, all this effort on type safety, memory ownership, reflection on unknown types, only to allow every single function call to explode without warning.

# No, it is clear to me, to butcher Churchill

# "Returning error values is the worst form of error handling, except all the others that have been tried."

# And in the context of collaboration, Go's error handling is the only form that makes sense.

* Errors and interfaces

# If you've working on some large Go projects you may have come across packages like Canonical's errgo, which provide facilities to apply a stack trace to an error value. 
# I want to be clear that I am remaining neutral on the relative good or badness of this idea.

# What I do want to highlight is even though one piece of code you integrate use fmt.Errorf(), and another a complicated library, from the point of view of the consumer of the language your error handling strategy looks the same. If the err is nil then the call worked.

# Consider this to the variety of error handling strategies that must be managed in other languages as programs grow through acretion of dependencies.

# This is the key to a Go programmer's ability to write an application at any size with the same levels of reliability.

* Simple build system

# Go's lack of Makefile is more than a convenience. It's part of making large interoperable software.

# With other programming languages, when you integrate something, maybe it's something complex, like v8, or something more mundane, like a database driver from your vendor, you're integrating that code into your program, this part is obvious, but you are also integrating their build system.

# This is a far less visible, and sometimes far more intractable problem. You've introduced not just a dependency on that piece of code, but also on its build system, be it cmake, scons, gnu autotools, what have you.

# Go simply doesn't have this problem.

# Putting aside the contentious issues of package versioning, once you _have_ the source in your GOPATH, integrating with ANY piece of third party Go code is just an import statement away.

# Go programs are built from just their source, which has everything you need to know to compile a Go program. I think this is a hugely important and equally underappreciated part of Go's collaboration story.

# This is also the key to Go's efficient compilation. If the source indicates only those things that it depends on, any nothing else, then compiling your program will touch only the lines of source necessary. Combined with the removal of header files, and a prohibition on circular imports Go can deliver efficient compilation for programs of huge size. 

* Sans runtime

# Does your heart sink when you want to try the hottest new project from Hacker News or Reddit only find it requires node.js, or some assortment of Python or Ruby dependencies ? Mine does.

# For Go programmers dependency managament remains an open wound, but for users of programs written in Go their life just got a whole lot easier; compile the program, scp it to the server, job done.

# This one fact alone has allowed Go to establish a commanding position in the container orchestration market, a market which would not exist in its current form if not for Go's deployment story.

* Portability

# Go’s fresh take on portability, without the requirement to abstract yourself away from the machine you program runs on, is like no other langauge available today.

C# isn’t portable, it’s joined at the hip to a Windows host.

Java, Scala, Groovy, and all the rest of the language built atop the JVM may benefit from the architecture indepedence of the JVM bytecode format, until you realise that Oracle is only interested in supporting the JVM on Intel hardware. Similarly the attempts to modularise the JVM to reduce its startup time remain perpetually one or two releases away.

Swift ? Don’t make me laugh, it joins Objective-C in the land of Apple only programming languages. Popular? yes, but portable? no.

The list of supported operating systems and architectures The ability to cross compile a Go program to any of these platforms is similarly unique. If you've every worked at a python shop with a late requirement that your application run on Windows, you'll know what I'm talking about.

* Real machines not virtual machines

In the new world of metered usage cloud deployments, the difference between a slow interpreted language, and a nimble compiled Go program is stark.

As well as cross platform as the superset of the expected capabilities, not the intersection.

Nobody would consider using Java for CLI apps

* A command line renesaunce

We've spoken earlier about McIlroy's pipe methodology for composing powerful programs from simple components.

We are in the early stage of a command line renaissance, a renaissance driven by the rediscovery of languages which produce compiled, self contained, programs. Go is leading this charge.

A command line renensance which enables developers to deliver simple programs that fit together, cross platform, in a way that suites the diverse needs of the nacient cloud automation community, and reintroduces a generation of programmers to the art of writing small, composable programs which fit together, as Doug McIlroy described, “like segments in a garden hose”

But being able to consume and produce streams of text, rather than mouse clicks or database tables, is only part of the story.

For the last few decades, since the rise of interpreted languages, or virtual machine runtimes, programming has been less about writing small target tools, and more about managing the complexity of the environment those tools are deployed into.

Slow languages, or bloated deployments encourage programmers to pile additional functionality into one application to amoratise the cost of the installation and setup support load.

This is a command line renescanunce that has been missing for a generation.

A key part of the renesaunce is Go's deployment story. Many of my fellow speakers have praised Go for its pragmatic deployment story, focusing on server side deployments, but I believe there is more to this.

Over the last year we've seen a number of companies shift their client side tools from interpreted languages like Ruby and Python to Go. Cloud Founrary, Github's hub, and Mongodb are the ones that spring to mind.

In every case their motivations were similar; while the existing tools worked well, the support load from 


Go lets you write CLI applications, that in turn enables developers to leverage the unix philosophy; small, sharp tools that work well together.

* Conclusion

# (5 minutes)

* Go is a simple language

.image simplicity/supermighty.png _ 800

# https://twitter.com/Supermighty/status/548897982016663552

# Go is a simple language

# This wasn't an accident.

# This was a deliberate decision, executed brilliantly by experienced designers who struck a chord with pragmatic developers.

* Go is a language for programmers who want to get things done

"I just get things done instead of talking about getting them done." -- Henry Rollins

# Put simply, Go is a language for programmers who want to get things done.

* Go is the right language at the right time.

# As Andrew Gerrand noted in his firth birthday announcement 

“Go arrived as the industry underwent a tectonic shift toward cloud computing, and we were thrilled to see it quickly become an important part of that movement.” -- Andrew Gerrand

# Go's success is directly attributable to the factors that motivated it's designers. As Rob Pike noted in his 2012 Splash paper. 

"Go is a language designed by Google to help solve Google's problems; and Google has big problems" -- Rob Pike

# And it turns out that Go's design choices are applicable to the problems that an increasing number of professional programmers face today.

* Go is growing

# November last year, Go turned 5 years old as a public project.

# In these 5 years, less if you consider that the language only reached 1.0 in April of 2012, Go, as a language, and a proposition to programmers and development teams, has been wildly successful.

# In 2014 there were five international Go conferences. In 2015 there are six, so far, plus

.image simplicity/growing.png 1200 _

# Ever growing engagement in social media; twitter, Google plus, ...
# An established community in the golang sub reddit
# Real time discussion communities like the #go-nuts IRC channel, or the slack gophers group.
# Go projects reguarly feature on hacker news
# Go featured in mainstream tech press, companies shipping api's in Go to talk to their services 
# Go training available in both professional and academic contexts.
# Over 100 meetups around the world
# [a] Sites like Damien Gryskies gophervids helping to desceminate the material produced by those meetups and conferences.
# Community events like GopherGala 

* Take the time to really learn the language

# This paper describes the language we have today. A language built with care and moderation. The language is what it is because of the deliberate decisions that were made at every step. Language design is about trade offs, learn to appreciate the care in which Go's features were chosen and the skill in which they were combined.

# While the language strives for simplicity, and is easy to learn, it does not immediately follow that the language is trival to master.

# There was s a lot to love in our language, don't be in such a hurry to dismiss it before you have explored it fully.

.image simplicity/amor.jpg

Learn to love the language. _Really_ learn the language, it'll take longer than you would think.

# Learn to appreciate the choices of the designers.

Go will make you a better programmer.

# Java.  Tone deaf to the requirements of a programming environment. The JVM is too sandboxed, to divorced from the reality of the environment it is working inside.

# Pike and Kernighan. The Unix programming environment. Note the plan 9 environment. Rob pike creates programming environments not just programs.

# Ruby and python are better citizens, but are hamstrung by the clumsy deployment strategies. A niche that Go fills well.

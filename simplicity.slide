Simplicity, and ideas that Go left behind
Closing Keynote, Gophercon India
21 Feb 2015

Dave Cheney
dave@cheney.net
http://dave.cheney.net/
@davecheney

* Overview

// TODO: not part of the presentation

- Introduction
- Simplicity
- Everything is not an object
- A language for collaboration
- Conclusion

* Opening

(5 minutes)

Hello, my name is Dave. I'm a programmer, and Go contributor from Sydney, Australia.

It is my honor to be your final speaker for today, and after having the priviledge of listening to the presentations from my fellow speakers I have the inenviable task of not repeating anything that they have said.

I'm lucky enough that I get to program in Go for my day job, and in my spare time, well, that's pretty much dedicated to Go as well.

I've been involved in porting Go to several new platforms, I've written and spoken a lot about Go performance, but, and I hope this doesn't dissapoint you, I'm not going to speak about any of those things today.

* Linked In image

// TODO: this is self agrandising clap trap, drop it

[ show picture of linked in ]

This is me.

What defines me as senior ? Why do I have a job ?

Senior generally implies advanced age -- which is certainly true -- but more accurately it defines a side effect -- I have a job because of my experience; experience gained over many years -- or if we’ve being truthful -- making mistakes.

I have a job, I have can parley my skills because I carry with me a lifetime of experience, mistakes made and lessons learnt with I offer to my employer -- hopefully with the promise that I won’t make those mistakes again.

What does this little monologue have to do with Go ?

Go reintroduces, or at least rediscovered some very old ideas, ideas promulgated by the experience of it's design team, influenced by lifetimes of experience as programmers involed in the trade, and craft, of software development.

* Thesis

I want to open my presentation with a proposion.

"Most programming languages start out aiming to be simple, but end up just settling for being powerful." -- https://twitter.com/davecheney/status/539576755254611968

Being passionate about Go means being passionate about language advocacy, and a natural hazzard of dwelling too long on the nature of programming results in statements like these.

But underneith the pithy form enforced by a tweet, I believe there is a gem of truth. I cannot think of a language introduced in my life time that didn't purport to be simple. All new langauges offer as a justification and an enticement, they're inherent simplicity.

On the other hand, I cannot also point to a language introduced in the same time frame with the rallying call of complexity; more complexity than its contemporaries -- but many instead claim to be powerful.

The idea of proposing a language which offered higher levels of inherent complexity is clearly laughable, yet this what so many contemporary languages have become; complicated, baroque messes that defines the inspiration for their replacement.

In language advocacy, accusing a language as being complex is one of the highest forms of rejection. I should know, I've made my share of cheap shots at C++.

So, every language starts out with simplicity as a goal, yet many of them fail, eventually falling back on the expressiveness or power of the language as justification for a failure to remain simple.

Clumsy syntax and non orthogonality is justified by the inherent complexity of capturing neuanced corner cases of the language, many of them are self inflicted by years of careless feature creap.

Any why is this ? Why do so many langauges, launched with idealistic goals, fall afoul of their own self inflicted complexity ?

One reason, one major reason, I believe, is that to be thought successful, a language should be a superset of the features of its prdecessors.

If you would listen to language critics, they demand that any new language should push forward the boundaries of language theory. But really this appears to be is a request your, new, should language to include all the bits they felt were important in their favorite old language, while still holding true to the promise of whatever it was that drew them to your new language I the first place.

"I want a language that is simple, but incoporates a full Hindley–Milner type system"

Why would a new language be proposed if not to address limitations of it’s predecessors?

Must simplicity be abandoned to deliver a complete programming language ?

* Quote

[ those who do not learn from history are doomed to repeat it [sic] ]

And I believe this is fundamentally an incorrect view.

Why should a new language not aim to represent a refinement of the cornucopia of features presented in existing languages, leaning from it's predecessors, rather than repeating their folly.

Language design is about trade offs, you cannot have your cake and eat it too.

So I challenge the notion that every main stream langauge must be a superset of the incumbents it seeks to replace.

* Simplicity

This brings me back to my tweet. Go is a language that chooses to be simple, and it does so by choosing to not include many features that other programming languages haveacustomed their users to believing are essential.

Go is a successful language in part, in no small part I believe, because of its decision to not include many of the popular language features which programmers have become accustomed to expecting,

So the subtext of my thesis would be; what makes Go successful is what has been left out of the language, just as much as what has been included.

* Simplicity is not a new idea

“you cannot add simplicity after the fact -- simplicity is only gained by taking things away”

Simplicity is not a new idea, although Go is the most recent language to place it at the forfrount.

Algol68 and PL/1, monuments to the second system syndrome produced solutions beyond both the hardware and the programmers of the day. 45 years later the hardware might be faster, but the complexity that one engineer can fit in their heads remains roughtly the same.

- counteracted by C and pascal

C++, an language which was already reguarded in 1995 as too complex, was superceeded by Java

* Simplicity is not easy

Simplicity does not necessarily mean “easy”, but it may mean “straight forward” or uncomplicated. 

Something which is simple may be time consuming; but reliable

A simple programming language may lack of semantic acourtriments in order to lower the bar to new devotees

A simple programming langauge may choose to limit the number of semantic conveniences which offer a minor improvement for experienced users at the cost of alienating newcomers.

As I said above, simple is not a synonym for "easy", nor is achieving a design which is simple an easy task.

* Don’t mistake simple for “crude”

Just because something may be simple, don't mistake it for crude.

While lasers are fabulous technology used in medicine and manufacturing, a chef will always use a knife to prepare food, an activity much more fundamental, and far more common place.

// TODO: time keeping, mechanical clock vs digital watch

* Simplicity is a goal, not a by product

You should design with simplicty as a goal, not to be pleasently surprised when your solution happens to be simple.

A lack of simplicity is, of course complexity. And complexity is friction, a force which acts against you getting things done.

* Choose simplicity over completeness. 

There is an exponential cost in completeness.

The 90% solution, one that remains orthogonal with some things which are not possible, vs a langauge attempting to offer 100% of its capabilities to every possible permutation will be inherently more complex, because as we engineers know, that last 10% costs another 90% of the effort.

* Good programmers write simple programs

Good programmers write simple programs. 

They bring their experience, their knowledge and their failures to new designs, to learn from and avoid mistakes in the future.

Do you have what it takes to write a simple program, or will you settle for a powerful program ?

* Simplicity, conclusion

"Simplicity is the ultimate sophistication" -- Leonardo DiVinci

Go is a language designed to be simple. It is a feature, not a by product, or an accident. This design for simplicity is woven through every aspect of the language.

* Everything is an object

(10 minutes)

* Definitions

What do we mean when we say objects ?

The first use of this term that I was surprised to read, was 1978 - the C programming language.

[ slide: show quote // chapter two “the C programming langauge”, first published in 1978 ]

Now, 37 years later, I don’t think anyone will say that the object that Kernighan and Ritchie were discussing is what they consider to be an object in the modern parlance.

To avoid a debate about what is, and what is not an object, and thus what it means to be object oriented -- or as I prefer, to have object semantics. Lets’ quickly recap the defining property of objects.

[ slide

An object has both state (data) and behavior (code).

]

Objects have both state, their fields, and behavior, their methods.

That’s it.

Ideas like inheritance, polymorphic dispatch, these are nice to haves, but are not the defining feature of object oriented semantics -- it is the fusion of state and behavior which distinguishes object oriented style from the procedural.

[ slide: timeline

     C (72)
     C++ (80 ? ) - sidenote, c with classes
     Java
     
     Perl
     Python
     Ruby
     Javascript
]

timeline shows the progression from languages without object semantics, to languages with optional object semantics, to languages with _manditory_ object semantics.

There is an implicit expectation that being entirely OO oriented is good, in fact, necessary to be considered a modern language.

And this is a concept I reject, and especially when discussing Go. In fact my respect for Go is seated in the fact that it was a language which rejected, as I mentioned earlier, the orthodoxy that to be accepted it must incorporate all the ideas de jour of it’s contemporaries.

Go is a language of refinement, minimal to the point of being stark. A language of contemplation, a language of reevaluation.

So, just as Go has demonstrated that inheretence is not necessary for composing effective programs, an idea which, compared to the other critisisms commonly leveled at Go appears to have been accepted favorably -- possibly giving my position credence.

* Everything is an object

Here is a question for the audience. Who said "Everything is an object" ?

- Java programmers
- Smalltalk programmers
- Ruby programmers

Who didn't say this ?

- C programmers
- Fortran programmers
- Pascal Programmers

They said this because their languages did not support objects, they did not support the concept of binding state and behavior into a single unit.

Now, in the middle we have most of the other languages, D, rust, python, Julia, Lua, and of course go.

And that means we have a choice, a choice of when to use function semantics and when to use object semantics.

- earliest langauges, speed coding - grace hopper, glofied languages

* OO 

[ slide:

quote: “Go is object oriented, but not as you expect” -- Rob Pike

]

OO hides data behind behaviour. Which might be what you want, if you're writing an application which deals with behavior.

But often you want to deal with data directly, using structures and functions. And Go lets you do that; everything is _not_ an object.

The history of Go looking at the language through the lens of history

Object complect state, identity and value.

Object were created to encapsulate IO devices. IO is fundamentally not immutable; reading a byte from a file descriptor twice will not give you the same data -- IO is not immutable.

Structures; fields, not methods, are immutable. When you read a piece of data out of a structure; it does not change!

Pedantic listneers will note that Go doesn't provide any notion of const, and this really goes to my initial point about simplicity, and a choice of features that work well together to solve the 90% problem, not a much larger set of features which begrudgingly copoerate to approach 100% completeness.

Go does assume some level of responsiblity from the programmer, it won't provide you will a full set of tools to prevent you shooting yourself in the foot.



What does Carmack mean ? 


[ https://twitter.com/ID_AA_Carmack/status/53512300451201024 ]

* Go doesn't force you to use objects

Data and behavior are different things

We have struts which represent pure data, and interfaces which represent pure behavior

* Functions not methods

easier to black box test

* Data structures are greater than code. 

public members over getters and setters
write programs that write programs, not code generation
encapsulate ideas as programs - regexp interpreter

* Interfaces, the unix way

[ https://twitter.com/jmoiron/status/532314843689132032 ]

In 1964 Doug McIlroy postulated about the power of pipes for composing programs , this is four years before Unix was written mind you.

In the last few decades programmers have lost the ability to compose prograns, lost behind waves of run time dependencies and bloated frameworks that degrade the ability to move quickly and experiment cheaply. 

We all know that methods and functions should take interfaces not concrete values.

But if your method does not do anything with its receiver then it remains trapped on the receiver, when it could be reused by other callers. 


In 1964 Doug McIlroy postulated about the power of pipes for composing programs , this is four years before Unix was written mind you.

In the last few decades programmers have lost the ability to compose prograns, lost behind waves of run time dependencies and bloated frameworks that degrade the ability to move quickly and experiment cheaply. 

We all know that methods and functions should take interfaces not concrete values.

But if your method does not do anything with its receiver then it remains trapped on the receiver, when it could be reused by other callers. 

* Everything is not an object

So maybe everything is not always an object. Maybe you just want a function, or a value.

* A language for collaboration

(10 minutes)

Large programs are written by large teams, I don't believe this is a uncontraversial statement. 

However, the inverse is also true, large teams of programms, by their nature, produce large code bases.

This is the nature of our work. Projects with large goals will 

- talk about how go allows teams to reduce complexity
- complexity budget
- technical debt ? what about complexity debt

Go is a small langauge, but it's unashamadly a language intended to be used on big projects.

This does not mean that Go is not suitable for the single developer working alone, or a small program written for a specific need, but speaks to the fact that a number of the choices within the language are aimed at growing software teams, and their needs.

The truth is that large software teams, through their very nature, write large programs.

- Controlling imports, which speaks to controlling build times.


* Programming languages as part of an environment

Ultimately Go is a langauge for the problems that exist in commercial programming, not language theory.
- Effective collaboration on large, distributed, projects
- dependency and deploynment
- loose coupling

- Efficient excution
- Powerful abstraction through simple interfaces

* Code is written to be decoded

The author Peter Norvig suggests that programs are not read, but decoded. In hindsight this should have been obvious, we call it 'source code', not 'source writing', the source is _en_coded into an intermediary form that is somewhere between our concept of the program, and the computer's executable notation.

As with many transformations, this encode of the source program is not lossless, some fidelity, some abiguity, some imprecision is present. This is why others reading source code must _decode_ it, to divine the original intention of the programmer


* How to build a Go community

The set of source code which is accceptable to the compiler is much larger than the set of code which is acceptable to go fmt. 

Go format is one of Go's great gifts to future generations of langauge designers. A language designed from the beginning to be transposed, transformed and processed, at the source level by tools which are not restricted to the compiler, have opened fields of analysis and code generation to the wider Go community.

But I believe the regular syntax of a Go source file belies its greatest champion; gofmt. 

So, if go formatted represents only a small % of valid source code, why is it importnat to use go fmt.

Part of the reason is to avoid needless debate
- large teams will by their nature have a wide spectrum of views on many aspects of programming, and code format is on of the most pernitious.

- go is a language for collaboration, in large teams, and in a large team, just as in a wider community personal choices are moderated for a harmoneous society.

So, nearly all go code is go formatted. It is formatted not by edict, the compiler is more permissive than gofmt, instead all go code is formatted by convention. Acceptance of this convention is an indicator of alignment with the values of Go.

In fact, code that is not well formatted can be a first order indicator of the suitability of the package. 

Now, I'm not trying to say that poorly formatted code is buggy, but poorly formatted code may be an indication that the authors have not understood the design principials that underscore Go. Buggy code can be fixed, but design issues or impedencene mismatches can be much harder to address, especially after it is integrated into your program.

* Batteries included

The Go standard library has been called both spartan, and complete; this of course depends on your point of view and your requirements at the time.

As Go programmers we can pick up any piece of Go writen by anyone in the world and start to read it. This is more than just formatting. 

Go lacks the heavy libraries like Boost. There are no qt base classes, no Gobject. 

The inclusion of maps and slices in the language side steps the most basic interoperability issues you have when working with C, C++ or Java code bases. Interfaces cover the rest.

These are the basic building blocks which programs built in those langauges, having adopted those frameworks will use. 

“code is not read, it is decoded” -- norvig. There is a hint in the word, source code, not language. The antonym of to code, or encode, is to decode -- and that is what we do as programmers.

* Error handling without exceptions

I've written a lot on the subject of Go's error handling, so I'll restrict my comments to the area of collaboration.

I've already described interfaces, of with the archetype is the error interface.

Java was the only main stream language to attempt to make exceptions checked, to make them part of the method's signature. The rational by Gosling at the time was sound, looking at the history of unchecked exceptions in languages that existeded in the 80's, which was basically c++, and saw the difficulty using libraries that relied on exceptions for error handling.

However it is clear by all modern standards that checked exceptions, however well intentioned, are an evolutionary dead end. In fact, modern C++ not only does not have checked exceptions, but has introduced a keyword to indicate that a method will never throw an exception.

So, if exceptions are to be used in a new language they will be of an unchecked variety.

What a waste, all this effort on type safety, memory ownership, reflection on unknown types, only to allow every single function call to explode without warning.

No, it is clear to me, and to butcher Churchill

"Returning error values is the worst form of error handling, except all the others that have been tried."

And in the context of collaboration, Go's error handling is the only form that makes sense.

* Errors and interfaces

If you've working on some large Go projects you may have come across librarys like Canonical's errgo, or XXX, which provide facilities to apply a stack trace to an error value. 

I want to be clear that I am remaining neutral on the relative good or badness of this idea.

What I do want to highlight is even though one piece of code you integrate use fmt.Errorf(),and another a complicated library, from the point of view of the consumer of the language your error handling strategy looks the same. if the err is nil then the call worked.

Consider this to the variety of error handling strategies in other languages.

And this is the key to a programmers' ability to write an application at any size with the same levels of reliability.

* Simple build system

Go's lack of makefiles is more than a convenience. Its part of making large interoperable software.

With other programming languages when you integrate something, maybe it's something complex, like v8, or something more mundane, like a database driver from your vendor, you're integrating that code into your program, this is obvious, but you are also integrating their build system.

This is a far less visible, and sometimes far more intractable problem. You've introduced not just a dependency on that piece of code, but also it's build system.

- cmake 
- scons
- makefiles
- automake
- ninja

There are no header files. There is no Makefile, or cmake. There are not multiple build systems.

Go simply doesn't have this problem either, just the source, which has everything you need to know to compile a go program. I think this is a hugely important and equally underappreciated part of Go's collaboration story.

Putting aside the contentious issues of package versioning, once you _have_ the source in your GOPATH, integrating with ANY piece of third party Go code is just an import statement away.

* Sans runtime

Does your heart sink when you try the latest Hacker News or Reddit bauble only find it requires node.js, or some assortment of Python or Ruby dependencies ? Mine does.

For Go programmers dependency managament remains an open wound, but for users of programs written in Go their life just got a whole lot easier; compile the program, scp it to the server, job done.

As well as cross platform as the superset of the expected capabilities, not the intersection.

* Real machines not virtual machines
As muted above
Simple, and fast

In the new world of metered usage, the difference between a slow interpreted language, and a nimble compiled Go program is stark.

Nobody would consider using Java for CLI apps


* Unix design philosophy applied to Go.

Interfaces let you talk about behavior, _not_ type. _Has a_, not _Is a_.

* Interfaces

interfaces are the key concept of talking about values by their _behaviour_

This is distinct, and an important departure from _classical_
inheretence based OO, but critically, _this is OO_, and I argue, a
more pure form.A

* A trend you say ?
Last year, Cloud Foundry switched to Go to provide the client tools for its PaaS offering citing the growing support load from users who were struggling to install their previous generation of Ruby based utilities.

In October, Jingwen Owen Ou, developer program member at Github,announced that their GitHub command line tool, hub, has been rewritten in Go.

That same month, MongoDB announced they had rewritten their suite of command line tools (mongodump, mongostat, etc) from C++ to Go.

Rewriting code is time consuming, risky, and sometimes of dubious benefit. So why are more and more companies opting for a change ?

* A command line renesaunce

What is something Go left behind ? GUI's

Now I don't mean to imply that GUI's are not important, and I recognise that the options for writing desktop applications in Go is still in it's infancy.

What I want to talk about is Go applications, live on the command line

We are in the early stage of a command line renaissance, a renaissance driven by the rediscovery of languages which produce compiled, self contained, programs.
The Go programming language is leading this charge.

A command line renescanunce that has been missing for a generation.

Many of my fellow speakers have praised Go for its pragmatic deployment story.

I want to echo their praise

Go lets you write CLI applications, that in turn enables developers to leverage the unix philosophy; small, sharp tools that work well together.

A command line renensance which enables developers to deliver simple programs that fit together, cross platform, in a way that suites the diverse needs of the nacient cloud automation community, and reintroduces a generation of programmers to the art of writing small, composable programs which fit together, as Doug McIlroy described, “like segments in a garden hose”

McIroy describes well behaved unix programs as fitting together like segments of a garden hose. But being able to consume and produce streams of text, rather tha mouse clicks or database tables, is only part of the story.

For the last few decades, since the rise of interpreted languages, or virtual machine runtimes, programming has been less about writing small target tools, and more about managing the complexity of the environment those tools are deployed into.

Slow languages, or bloated deployments encourage programmers to pile additional functionality into one application to amoratise the cost of the installation and setup support load.

* Portability

Go's portability story is like no other language shipping today.

The ability to cross compile a Go program to any of the supported architectures

Go’s fresh take on portability, without the requirement to abstract yourself away from the machine you program runs on.

C# isn’t portable, it’s joined at the hip to a Windows host.

Java, Scala, Groovy, and all the rest of the langauges built atop the JVM may benefit from the architecture indepedence of the JVM bytecode format, until you realise that Oracle is only interested in supporting the JVM on Intel hardware. Similarly the attempts to modularise the JVM to reduce its startup time remain perpetually one or two releases away.

Swift ? Don’t make me laugh, it joins Objective-C in the land of Apple only programming languages. Popular? yes, but portable? no.

There is even a web service which will cross compile, http://gobuild.io/
Windows ? Go’s Windows support, developed entirely in the community
Ruby and python and perl always have runtime dependencies.

* A programming environment, not [just] a programming language

not just a place to write source code

It may appear heretical to suggest this, as many of the metrics that we, as professional software developers are judged by; lines of code written, changed or deleted; the number of revisions committed to source control, etc. But writing a program, or more accurately solving a problem; delivering a solution, has little to do with the final act of entering the program into the computer.

* Programming languages as part of an environment

Go is designed for programming in the large

 - Java.
Tone deaf to the requirements of a programming environment. The JVM is too sandboxed, to divorced from the reality of the environment it is working inside.

Pike and Kernighan. The Unix programming environment. Note the plan 9 environment. Rob pike creates programming environments not just programs.

Ruby and python are better citizens, but are hamstrung by the clumsy deployment strategies. A niche that Go fills well.

* Conclusion

(5 minutes)

* Go is a simple language

[ https://twitter.com/Supermighty/status/548897982016663552 ]

Go is a simple language

This wasn't an accident. This was a deliberate decision, executed brilliantly by the Go authors who struck a chord with pragmatic developers.

* Go is growing. 

November last year, Go turned 5 years old as a public project.

In these 5 years, less if you consider that the language only reached 1.0 in April of 2012, scarcely three years ago, Go, as a language, and a proposition to programmers and development teams, has been wildly successful.

- In 2014 there were five international Go conferences. In 2015 there are six, so far, plus

[ google trends graph ]

- Social media
- reddit.com/r/golang
- Go projects reguarly feature on hacker news
- Go featured in mainstream tech press, companies shipping api's in Go to talk to their services 
- Go training in both professional and academic contexts.
- Over 100 meetups around the world
- [a] Sites like Damien Gryskies gophervids helping to desceminate the material produced by those meetups and conferences.

- Community events like GopherGala 

* Go is the right language at the right time.

As Andrew Gerrand noted in the fifth birthday announcement blog post
“Go arrived as the industry underwent a tectonic shift toward cloud computing, and we were thrilled to see it quickly become an important part of that movement.”

Ultimately Go's success is directly attributable to the factors that motivated it's designers. As Rob Pike noted in his 2012 Splash paper. 

"Go is a langauge designed by Google to help solve Google's problems; and Google has big problems" -- Rob Pike, 2012

And it turns out that Go's design choices are applicable to the problems that an increasing number of professional programmers face today.

* Go is a language for programmers who want to get things done (tm).

[ Deloris Herbig picture ]

Put simply, Go is a language for programmers who want to get things done.

* Take the time to really learn the language

This paper describes the langauge we have today. A language built with care and moderation. The language is what it is because of the deliberate decisions that were made at every step. Language design is about trade offs, learn to appreciate the care in which Go's features were chosen and the skill in which they were combined.

While the langauge strives for simplicity, and is easy to learn, it does not immediately follow that the langauge is trival to master.

There was s a lot to love in our language, don't be in such a hurry to dismiss it before you have explored it fully.

Learn to love the language. _Really_ learn the langauge, it'll take longer than you would think to _really_ understand the langauge. Learn to appreciate the choices of the designers. Go will make you a better programmer.

Thank you.

* Notes

- profressional programmers use professional tools. Fast programming langauges, efficient solutions, 

And the designers chose to do this, not for a malicious reason, but because they explicitly chose to be minimalist, the choice to include a feature was not the default, it was, as Pike said in his "less is exponentially more talk" of twenty twelve, the choice to include a feature was made only when all three, Robert, Ken and himself,  were convinced of its utility.

Simple parts connected by well defined interfaces. 

Well defined interfaces are more likely to be small interfaces; the prevailing idiom are interfaces with single methods.

And small interfaces lead to simple implementations

* Unifying ideas

Interfaces in Go are a unifying force; the are _the_ means of describing abstract behaviour.

Thanks to the interface, I have realized the true composability such as the Unix pipe. #gocon

io.Reader and io.Writer became architecture that connects between the true component. #gocon This is where it is believed from the unix philosophy

- I use Fpirntf to the direct network connection


Go Proverbs
Gocon
24 Apr 2016

Dave Cheney
dave@cheney.net
http://dave.cheney.net/
@davecheney

* Thank you for inviting me to speak

Before I begin my talk, I want to express my gratitude to the organisers of GoCon for inviting me to speak today.

This is my third time visiting 東京 and the second time I have had to honor of speaking at GoCon.

# I love japan, and i love that you love Go. 

I was in China last week giving a technical talk about Go, but as I was given the honor of being the first speaker today I wanted to prepare something special for you.

If you are intersted, I'll post post my GopherChina talk online in a few days, so make sure you follow me on twitter for the link.


* Introduction

I want to start this talk with a little background. over the last few years I've been collecting notes on topics to write about on my blog, things to speak about, ideas from talking with friends, online, etc.

Originally i wanted to write them up as blog posts, but quickly i realised that I had so many it would be a huge undertaking. so

* Practical Go

[ image, book: Practical go

warning: not a real book ]

I thought about writing a book, and before you get to excited, no, i haven't written a book, and that is for all the usual reasons.

But more profoundly, I havne't written a book because I was never able to develop the theme that I wanted

So, what was the theme that I failed to discover. well, as many travellers will tell you,  you should travel the world with your eyes open -- surely a good safety tip -- but what they really mean is, when you travel the world, be open to the ideas and expereinces you will ahve along the way, don't let your preconditions color your interpretations, don't got out into the world decidin gthat you already know all the answers.

So, what was my precondition when I tried to write this book ? What had I decided was the truth, and I just needed to find evidence of that.

In a word rules.

It is so common, as programmers for us to ask quetions like

what is the _right_ way to do something

When should I do X, and when should I do Y

A Go programmers, when should I use and interface, when should I use a concrete type

When should I use a function and when should I use a method

When shoudl I declare a method on a pointer, when should I declare a method on a value

What is the right way to handle errors.

And looking at my stack of notes I said to myself

"I think I can answer these questions, I'm going to write a book with the answers for Go programmers to these questions"

And I felt that it must be possible. I mean if Scott Meyers can write books about this for C++, Go, a much simpler langauge should be easy -- right ?

And to make a long story short, after months of writing and thinking and talking to people I realise that I had made a mistake.

And that mistake was, there are no rules that i can give to explain how I think GO programs should best be written.

In fact, the only rule I could come up with, after months of writing was

"It depends"

And it depends is something that as an engineer I say a lot, maybe you do as well.

David, what's the best way to handle uploads to our application

Well, it depends,

[ and so on ]

And it's not that I'm being difficult, or non comittal, the it depends is always a prelude to asking questions about how they want to _use_ the thing that they have asked me to build.

And this here is the _essence_ of design. Design is about creating a solution that works without the constraints of the environment which it will be used.

Here in Tokyo for example I've seen a lot of these

[ picture, tiny car ]

So, why are these popular here ? Why did someone design a car so specific for Tokyo ?

One answer is tokyo is very crowded city, small lanes, space is at a premium, so if you design a car with a smaller footprint, it will be easier to drive in Tokyo and easier to park.

So, coming back to It Depends.

What I realised working on this book is it is going to be difficult to come up with a set of rules that you can apply  to writing GO programs. And the clue there is really in the word

rules / patterns /  laws

these are all very concrete ideas, everyone must follow the rules, everyone must obey the law, you _should_ use this pattern when designing your software. IN fact, we have books giving 50 patterns that you can use.

But what I realised in the end is that the reader of this book is not looking for rules, or patterns, but advice.


In NN of 2015 Rob Pike gave a talk called "Go proverbs", hopefully many of you have seen it`. In this talk he outlined, in the theme of another book, also calle Go prbervs.

Who knows what a proverb is. It's a story, a very short story, that a master may say to his student, or a parent to a child. 

And part of the magic of a proverb is that there is a difference between knowing the proverb and known it's meaning. They are a guide to meaning.

So, today I'm going to talk about the Go proverbs, not all of them, we don't have time for that, and explain what they mean to me, and hopefully by expample, they will become clearer to you.

# https://en.m.wikipedia.org/wiki/Japanese_proverbs

* ことわざ

# kotowaza -- proverb

* 井の中の蛙大海を知らず

# Can someone read this for me ?
# Can you translate it for me ?

# a frog in a well does not know the great ocean

# i no naka no kawazu taikai o shirazu

# What is the story of the frog in the well ? What does it teach us ?

# If you are the frog in the well you may think you know it all, you know your small surrondings intimately, there are few who understand what it is to live in this well like you do.
# But, the world outside your well is vast in comparison, and your knowledge very limited

https://en.wikibooks.org/wiki/Chinese_Stories/The_frog_of_the_well

* 井の中の蛙

# So if I say you to you all I no naka no kawazu, maybe some of you understand it, and those who do understand it not from the words "a frog in a well", but because you have learnt their meaning.

# You have to understand the meaning to understand the proverb.

* Go proverbs

https://www.youtube.com/watch?v=PAAkCSZUG1c

Last year Rob Pike gave a talked entitled "Go Proverbs", inspired by the english translation of this famous book by Segoe Kensaku

http://senseis.xmp.net/?SegoeKensaku

In his talk, Sensei Pike asked

"Are there Go proverbs?"

* Go proverbs

https://go-proverbs.github.io/

The answer is yes, there are Go Proverbs, you may recognise some of them already

Don't communicate by sharing memory, share memory by communicating.

Concurrency is not parallelism.

Channels orchestrate; mutexes serialize.

The bigger the interface, the weaker the abstraction.

Make the zero value useful.

interface{} says nothing.

Gofmt's style is no one's favorite, yet gofmt is everyone's favorite.

A little copying is better than a little dependency.

Syscall must always be guarded with build tags.

Cgo must always be guarded with build tags.

Cgo is not Go.

With the unsafe package there are no guarantees.

Clear is better than clever.

Reflection is never clear.

Errors are values.

Don't just check errors, handle them gracefully.

Design the architecture, name the components, document the details.

Documentation is for users.

Don't panic.

[ read list ]

But just like the parable about the Frog

Rules are written down, but principals must be learnt

So how do we learn the principal's of software development? How do we gain the experience to judge ours designs with the eye of a master?

So today I want to talk about some of the proverbs, and explain what they mean to me, while talking about the features of go design that are important to me

Simply, by study.

* Documentation is for users

Rob Pike is a great fan of documentation, you can see his influence in the language.

Have you ever had to write a manual for a program, maybe for a user, or for someone else using your library ?

How long did it take before that document was wrong, because you'd changed something, or added a new feature, or the product made it to version 2.0 and you wrote a new user interface. 

I'm sure we've all experienced that, and have read documentation from other products that was out of date.

The readability of programs is immeasurably more important their writeability. -- C. A. R. Hoare

http://i.stanford.edu/pub/cstr/reports/cs/tr/73/403/CS-TR-73-403.pdf

- documentation is for users, explain documentation, comments and the different kind of comments.
- errors are just values, explain the three heriarchies of error handling
- interfcaes, when to use them, how to write them, when to use a method rather than a function -- to implement an interface.

Who are the users of your code? 

Naming and comment ary

The source code is meant to be read

It will be read many more times than it is written

* If you cannot document it, do you understand it ?

* Errors are just values

* Error handling 

- you shouldn't be using sentinal values
- you shouldn't be making up your own sentinals 
- you shouldn't use a sentinal in more than on place, because then you won't be able to track down where it came from 
- so, if you shouldn't use sentinals, and you shouldn't use them more than once, then you're better off treating the error as opaque and using errors.New("exact problem") every time.

* communicate via sharing memory, is about ownership, talk about ownership, channels, rust and const

Even thought this was the first proverb we ever learnt about Go, published way back in 2009 [ link to blog ] I have chosen to leave it til last.

I have been studying Go for 6 years now and I must tell you that despite this being the first proverb I learnt about Go, it was the one that took me the longest to understand -- and even now I am not entirely sure that I truly understand its meaning.

Part of the difficulty I believe is that this proverb has mutliple meanings, it provides many lessons -- hence the confusion.

So, I will do my best to untagle it, and explain each of the meanings.

* Communicate with data, not with messages

The first, and most obvious meaning of

> Don't communicate by sharing memory, share memory by communicating.

Is rather than sending signs between goroutines, send the data itself.

As an example, imagine if I wanted to send you a letter by mail, I would give the letter to the post office, who would then go to your house and leave a note in your letterbox telling you that there is a letter for you and you should come to collect it from your post office.

This would be quite annoying, they already came to your house, but instead of leaving the letter, all they left was a message for you to come and get the letter. 

So you go to the post office and show them the note that was left for you, but you have arrived to quickly, the letter is still in transit, so you have to come back later, which your letter is ready.

This is the sort of using locks and shared memory.

Rather than just send you the value, one goroutine told another that it was 

Talking about letters and post offices again, you can imagine how complicated this would be if I wanted to send everyone in my family a letter, not only would each of my family have to take the note to their post office to receive their copy of the letter, but some will arrive to early, and others may accidentally be given several copies of the letter by mistake, so other family members, no matter how many times they ask, will never receive their copy of the letter.

Back in the land of Go, this story is simpler. We can solve all the problems with locks and polling with channels. When a receive operation completes you don't just have the notification that a message is available, you have the actual data.

So this is one of the lessons of 

> Don't communicate by sharing memory, share memory by communicating.

That using channels to communicate between goroutines is much simpler, much easier to understand and reason about, than using locks, and shared memory.

* Ownership

But there are also other lessons that  

> Don't communicate by sharing memory, share memory by communicating.

has to teach us. 

The second lesson is about ownership of resources. There are many kinds of resources

- a value in memory
- a channel
- a file
- a network socket

And other types that you create in your own programs. But really it's the ownership of memory that is the most important, and this is because we live 
in a world where modern computers have 

* Channel ownership

Channel ownership, who owns the channel, only the owner may close it.

You do not need to close a channel for it to be garbage collected, that will happen once every reference to your channel has been discarded.

Closing the channel is a signal, soem metadata apart from the channel values themselves

But the two are related, because most consumers wait for channel to be closed, and won't exit, thus drop their reference to this channel.until it is closed.

From this we draw two recommendations

> Only the owner of a chanel may close the chabel

> Never start a goroutine without knowing how it will stop.

* Conclusion

I hope that this has been informative for you.

Proverbs are a great way of encapsulating information; capturing the essence of a story or teaching a moral. But they can equally be bewildering to newcomers who do not know the story behind the proverb.

I hope that you will watch Sensei Pike's video, I think it was a wonderful presentation and I cannot recommend it enough to each of you.

I hope that my explanations have been informative, and I will leave you to consider the meaning behind the other proverbs which I did not have time to discuss today.

And I will leave you with a proverb of sorts, not of my own, but one I think is appropriate

http://english.stackexchange.com/questions/38837/where-does-this-translation-of-saint-exuperys-quote-on-design-come-from

* Simplicity is the ultimate form of sophistication —Leonardo da Vinci

Thank you.

https://en.wikipedia.org/wiki/Shibui

Shibui  渋い

I want to close, not on a proverb, but on a beautiful word that I discovered in my research.

And I like this word, because if there is a word which I think properly describes my feelings about Go, it is Shibui. 

An restrained design, functional without a course agrecultural design.


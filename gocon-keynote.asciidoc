= Errors are just values
Dave Cheney <dave@cheney.net>
v1.0, 24th April, 2016

== Preface

Good morning! Thank you for coming to my talk.

Before I begin my talk, I want to express my gratitude to Ueda-san and the organisers of GoCon for inviting me to speak today.
I also want to acknowledge the generous sponsorshop of our hosts, Cyber Agent, for providing the venue for today.

This is my third time visiting 東京 and the second time I have had to honor of speaking at GoCon.
I was in China last week giving a technical talk about Go.
If you are interested, you can find the link to my GopherChina presentation on my website, or you can follow me on twitter.
But as I was given the priviledge of being the first speaker today I wanted to prepare something new for you.

== ことわざ (kotowaza; proverb)

[quote]
井の中の蛙大海を知らず (i no naka no kawazu taikai o shirazu)

Loosely translated into english, this proverb reads

[quote]
A frog in a well does not know the great ocean.

Sometimes it's told as _a big fish in a small pond_, in fact, this is one of the translations that Google gave me.

The parable of the Frog in the well is told in many cultures. 
In Mao's China, apparently the frog was a tyrant of the well.
In California, the frog parable is commonly known as the Blub Paradox.footnote:[http://www.paulgraham.com/avg.html]

What is the story of the frog in the well trying to teach us ?
If you are the frog sitting in your well, you may think you know all there is to know.
You know your small surrondings intimately, yet you are also unaware of just how small your home is compared to the vast world outside, and how limited your knowledge is.

The lesson is; question your environment, question your assumptions, don't assume you are right just because nobody has yet convinced you that you are wrong. 

== 井の中の蛙 (i no naka no kawazu)

So if I say to you _I no naka no kawazu_, maybe some of you understand my advice, and those who do, understand it not from the words _a frog in a well_, but because you understand their meaning.
You understand the _lesson_ that the story of the frog in his well is teaching you.

Part of the challenge of a proverb is that to understand a proverb, you have to understand its meaning, not simply repeat the words.

== Go proverbs

Last year Rob Pike gave a talked entitled "Go Proverbs",footnote:[https://go-proverbs.github.io/] inspired by the english translation of this famous book by Segoe Kensaku.footnote:[http://senseis.xmp.net/?SegoeKensaku]

In his talk, Rob Pike asked, "Are there Go proverbs?", and answer is yes, there are indeed Go proverbs, you may recognise some of them.

.Go proverbs
* Don't communicate by sharing memory, share memory by communicating.
* Concurrency is not parallelism.
* Channels orchestrate; mutexes serialize.
* The bigger the interface, the weaker the abstraction.
* Make the zero value useful.
* `interface{}` says nothing.
* `gofmt`'s style is no one's favorite, yet gofmt is everyone's favorite.
* A little copying is better than a little dependency.
* Syscall must always be guarded with build tags.
* Cgo must always be guarded with build tags.
* Cgo is not Go.
* With the unsafe package there are no guarantees.
* Clear is better than clever.
* Reflection is never clear.
* Errors are just values.
* Don't just check errors, handle them gracefully.
* Design the architecture, name the components, document the details.
* Documentation is for users.
* Don't panic.

Just like the story of the frog, to understand these Go proverbs, you must understand the lessons they try to teach, not simply memorise the words.

My goal today is not to repeat Sensei Pike's words, I cannot do them justice.
Instead I want to talk about just one aspect of Go's design, and relate these ideas to a Go proverb as I understand them.

== Errors are just values

[quote, Go proverb]
Errors are just values.

This statement is universal in a Go programmer's phrase book, but what do Go programmers mean when they say "errors are just values"?

When we say "errors are just values", we actually mean "any value that implements the `error` interface is an error".
Saying "errors are just values" to someone who is a student of Go is not useful.
The student must understand the underlying message of the proverb to appreciate it.

This is a good place to start the discussion on what it truly means to understand Go's error handling philosophy.

== Programming with errors

Error handling is as important as the rest of your code.
It's as important as checking the loop index for the exit condition, or checking the result of a shift operation for overflow, or testing the result of a multiplication is within the expected bounds, that's how fundamental error handling is to Go.
And, just like shifting or comparisions or multiplication, error handling is a first class responsibility of all Go programmers.
Because, you have to plan for failure.
You have to always write your code with the assumption that sometimes the operation will fail.
And this is especially important when working with a distrbuted system, because the percentage of failures that occur increase with the number of actors in the system.

I've spent a long time thinking about the best way to handle errors in Go programs.
I really wanted there to be a single way to do error handling, something that we could teach all Go programmers by rote, just as we teach mathematics, or the alphabet.
But, probably unsurprisingly given the topic of this talk, I have concluded that there is no single way to handle errors.
By the same token, error handling is not an unbounded spectrum of possibility.

Error handling techniques can be roughly classified into the three core strategies, which I will illustrate.

// diagram, heirarchy of error handling.

As the diagram, and the remainder of this talk will hopefully show, each error handling strategy involves a set of tradeoffs that you, the author, must manage.

=== Sentinel errors

The first category of error handling is what I call _sentinel errors_.
The name decends from the practice in computer programming of using a specific value to signify that no further processing is possible.footnote:[https://en.wikipedia.org/wiki/Sentinel_value]
Some examples of this pattern from other languages are the C convention of returning `-1` on error.
For many languages, returning `null` when no more data is available is a common, but fraught, practice.

And so to with Go, we use specific values to signify an error.
Examples include values like `io.EOF`, or the more recent `io.UnexpectedEOF`.
Low level errors like the `syscall.Errno` type also fall into this category.
There are even sentinel errors that signify that an error _did not_ occur, like `go/build.NoGoError` and `path/filepath.SkipDir`.

Sentinel errors behave like constants.
In fact, when using them, you program with them exactly the same as constants.
For example, consider this piece of C code

[source]
----
int n;
n = read(fd, buf);
if (n == -1) {
     perror(...);
}
----

And compare it to some Go code that uses the `io.EOF` sentinel value.

[source]
----
n, err := r.Read(buf)
buf = buf[:n]
if err == io.EOF {
     // handle error
}
----

Using sentinel values is the least flexible error handling strategy as client code must compare the result to an expected value using the _equality operator_.
Sentinel values present a problem when you want to provide more context as wrapping or annotating them with other error types would break equality.

Even something as well meaning as this will defeat the caller's equality test.
[source]
----
return fmt.Errorf("unexpected error: %v", err)
----

The caller will be forced to looking at the output of the error's `Error` method to see if it matches a specific string.

****
As an aside, you should _never_ do this. The `Error` method on the `error` interface exists for humans, not code.
The contents of that string belong in a log file, or displayed on screen.
They should not be used for controlling the logic in your program.
Yes, I know that sometimes this isn't possilbe, but today we're talking about proverbs and lessons.
****

Sentinel error values create a source code dependency between two packages.
To check if an error is equal to `io.EOF`, your code must import the `io` package.
This specific example does not sound so bad, but imagine the tight coupling that exists when many packages in your project export various error values; you must import each of them to check for specific error conditions.
Having worked in a large project that toyed briefly with this pattern, the spectre of bad design--an import loop--was never far from our minds.

Sentinel values are often associated with helper functions that inspect them, themselves replete with complicated platform specific code to normalise cross platform differences.
A good example is this is the `os.IsNotExist` helper which is intimately aware of the ways a sentinel error value can be wrapped or smuggled inside another error type.

If your public function or method returns an error of a particular sentinel value, then the value must be documented, and of course the value's definition must be exported.
This adds to the surface area of your API and counts against the package's complexity budget.

If your code implements an interface who's signature defines a specific sentinel value, all implementors of that interface need to depend on the package in which that sentinel value is defined, again adding unintentional coupling between packages.
Perniciously, if the interface method is defined to return a specific error value, all implementations are thereby restricted to the vocabulary defined in the interface, even if they _could_ provide a more useful error.

So, my advice to you is to avoid using sentinal error values.
Their limited uses within the standard library is not a pattern you should emulate.

=== Error types

Error types are the second form of error handling I want to talk about.
An error type is not simply the value of calling `errors.New` or `fmt.Errorf`, but a new type that implements the error interface.

	type MyError struct {
		message string
		file string
		line int
	}

	func (e *MyError) Error() string { return fmt.Sprintf("%s:%d: %s", e.file, e.line, e.message) }

	return &MyError{"Something happened", "file.go", 200}

Because an error is now implemented as a type, not a value, callers can use a type assertion to check, thereby converting the error value into a concrete type which contains more information.

	err := something()
	switch err := err.(type) {
	case nil:
		// call succeeded
	case *MyError:
		// handle my error
	default:
		// unknown error
	}

Returning an error of a particular type, rather than a specific value is more flexible.
You can extend the information returned to the caller by adding fields to the type over time without breaking the caller.

And by far the most important improvement of error types over error values is their ability to wrap an underlying error in a new type to provide more context.
An excellent example of this is the os.PathError type

	type PathError struct {
	    Op   string
	    Path string
	    Err  error
	}
	    PathError records an error and the operation and file path that caused
	    it.

	func (e *PathError) Error() string

However, error types must still be documented in the API, and the error types of your API must be public, so the caller can use a type assertion or type switch.
Like error values error types increases the surface area of your package, and exibits the same design problems of coupling interface implementations to the source pacakge that defines error types.

New implementations must only return types specified in the interface’s declaration, even if they are a poor fit.
The error type cannot be changed or deprecated after introduction without breaking compatibility, making for a brittle API.

Callers should feel no more comfortable asserting an error is a particular type than they would be asserting the string returned from Error() matches a particular pattern.

=== Opaque errors

The most flexible error handling strategy, requiring the least coupling between code and caller, is to treat the error value from a function or method as opaque.
As the caller, all you know about the result of the operation is that it worked, or it didn't.
That is to say, a test that error is nil indicates if the call succeeded or failed, and that’s all there is to it.

If you adopt this position, then error handling becomes significantly more useful as a debugging aid.
For example, as your contract with the caller specifies no particular error type or value, you can now annotate errors with additional context.

Opaque errors enable _gift wrapping_, which is a general version of the previous error type's methodology--except in this case you do not know the type you are asserting to.

Show net.Error, vs defining your own type.

Error types can also host methods unlocking the more powerful technique of asserting an error to an interface, rather than with a type assertion.
A counterexample to the previous os.PathError type, is the net.Error interface type, which defines behaviours that error values that types satisfying the other interfaces in the net package, like net.Listener and net.Conn.

Errors are part of your package's public API, treat them with as much care as you would any other part of your public API.
Choosing how errors are communicated is the responsibility of the package's author and your decision impacts the usability of your package. Choose wisely.

- you shouldn't be using sentinal values
- you shouldn't be making up your own sentinals 
- you shouldn't use a sentinal in more than on place, because then you won't be able to track down where it came from 
- so, if you shouldn't use sentinals, and you shouldn't use them more than once, then you're better off treating the error as opaque and using errors.New("exact problem") every time.

A small number of cases, generally revolving around interactions with the world outside your process, like network activity, require that the caller investigate the nature of the error to decide if it is reasonable to retry the operation.

Don’t assert an error value is a specific type, but rather assert that the value implements a particular behaviour.

This suggestion fits the has a nature of Go’s implicit interfaces, rather than the is a [subtype of] nature of inheritance based languages. Consider this example:

func isTimeout(err error) bool {
        type timeout interface {
                Timeout() bool
        }
        te, ok := err.(timeout)
        return ok && te.Timeout()
}
The caller can use isTimeout() to determine if the error is related to a timeout, via its implementation of the timeout interface, and then confirm if the error was timeout related — all without knowing anything about the type, or the original source of the error value.

Gift wrapping errors, usually by libraries that annotate the error path, is enabled by this method; providing that the wrapped error types also implement the interfaces of the error they wrap.

This may seem like an insoluble problem, but in practice there are relatively few interface methods that are in common use, so Timeout() bool and Temporary() bool would cover a large set of the use cases.

=== Don't just check errors, handle them

[quote, Go proverb]
Don't just check errors, handle them.

What's wrong with this, very common, piece of Go code?

[source]
----
err := doSomething()
if err != nil {
    return err
}
return nil
----

Firstly, it's too verbose.
If `err` is not nil, then we return the error, but if `err` is nil, then we don't need to explicitly `return nil`.
We can just return `err`, because we _know_ that it is nil.
So this whole stanza can be rewritten to be clearer.

[source]
----
return doSomething()
----

Ok, that was the easy stuff.
Anyone should be able to spot this in code review.
But what are some of the more serious problems with this code?

The most serious problem, to me at least, is that I cannot tell where the error originated.
At the top of my program I might print out the error to find the result is "EOF".
There is no information of what file and line the error was generated, there is not stack trace of the call stack leading up to the error.

Donovan and Kernighan's __The Go Programming Language__footnote:[http://www.gopl.io/] recommends that you add context to the error path like this

[source]
----
err := something()
if err != nil {
	return fmt.Errorf("something failed: %v", err)
}
----

But as we saw earlier, this pattern is incompatible with the use of sentinal error values, and type assertion.
Using fmt.Errorf to convert the error value to a string, then merging it with another string, and converting the result to a type that implements the `error` interface destroys all the context of the original error.

Perhaps this is what you want.
After all, I did argue that most callers should treat errors as opaque.
But there will be some place in your code, possibly close to the `main()` function, that is responsible for extracting debugging information from the error.

=== Annotating errors

I'm going to talk a bit about how I add context to errors, and to do that I'm going to use a very simple `errors` package.

The code is online at github.com/pkg/errors footnote:[https://github.com/pkg/errors], I'll just recap the API

	package errors

	func Wrap(cause error, message string) error
	    Wrap returns an error annotating the cause with message. If cause is
	    nil, Wrap returns nil

	func Cause(err error) error
	    Cause returns the underlying cause of the error, if possible. An error
	    value has a cause if it implements the following interface:

	        type Causer interface {
	               Cause() error
	        }

	    If the error does not implement Cause, the original error will be
	    returned. If the error is nil, nil will be returned without further
	    investigation.

And using these two methods, we can now annotate any error, and recover the underlying error.

TODO: show wrap, 

TODO: show cause and type switch.

Does this add boilerplate, yes. But how else do you expect to get these features? Importantly, error handling is composable, you can opt in at every level

Performance, does this inspection and wrapping take time? Yes ? Does it matter ? No
If the performance of your error path is a limiting factor, you need to redesign your application.

=== Handle the error once

Lastly, you should only handle the error once.
Handling an error means inspecting the error value, and making a decision.
You should always make one decision.
If you make less than one, you're ignoring the error, this is obvious.
But making more than one decision in response to an error is also a bad thing.

Using this errors package, or one like it, gives you the ability to add context to error values, in a way that is inspectable by both a human and a machine.
This means instead 

I recommend that you should, either, annotate the error and return it to the caller, or, log the error.
In logging the error you have handled it, there is no reason to handle the error twice.
If after you've logged the error, your program cannot continue, then logging the error was the wrong choice.

=== In conclusion

For maximum flexibility, treat all errors as opaque.

Assert errors for behaviour, not type

If API returns a specific error value, be aware of the limitation that places on all callers.

If your interface returns a specific error value, be aware of the restriction that places on all implementatations.

Minimise the number of sentinel errors, they are part of your public API and must be handled explicitly all the way up the call chain.

Convert sentinal errors to opaque errors by wrapping them as soon as possible to minimise the weight of your API boundary.

Use errors.Cause, or assert to interface { Cause() error } to recover sentinal errors. 

== Epilog

Proverbs aren't rules or laws, they're just stories, and how well you understand the story defines how well you understand their lesson.

Proverbs are a great way of encapsulating information; capturing the essence of a story or teaching a moral. But they can equally be bewildering to newcomers who do not know the story behind the proverb.

I hope that you will watch Sensei Pike's video, I think it was a wonderful presentation and I cannot recommend it enough to each of you.

I hope that my explanations have been informative, and I will leave you to consider the meaning behind the other proverbs which I did not have time to discuss today.

I want to close, not on a proverb, but on a beautiful Japanese word that I discovered in my research.

== 渋い (Shibui)
// https://en.wikipedia.org/wiki/Shibui

And I really like this word, because if there is a word which I think perfectly describes my feelings about Go, it is Shibui. 

It is an elegant design, a restrained design, and above all a simple design.
The union of form and function.

Thank you.

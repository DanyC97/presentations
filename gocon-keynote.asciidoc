= Go Proverbs
Dave Cheney <dave@cheney.net>
v1.0, 24th April, 2016

== Preface

Before I begin my talk, I want to express my gratitude to Ueda-san and the organisers of GoCon for inviting me to speak today.
I also want to acknoledge the generous sponsorshop of our hosts, CyberAgent, for providing the venue for today.

This is my third time visiting 東京 and the second time I have had to honor of speaking at GoCon.
I was in China last week giving a technical talk about Go, but as I was given the honor of being the first speaker today I wanted to prepare something special for you.
If you are intersted, I'll post post my GopherChina talk online in a few days, so make sure you follow me on twitter for the link.

== Introduction

I want to start this talk with a little background.
Over the last few years I've been collecting notes on Go topics, things to speak about, ideas from talking with friends, online conversations, an so on.
Originally I wanted to write them up as blog posts, but I quickly realised that I had so many it would be a huge undertaking. 

I thought about writing a book, and before you get to excited, no, i haven't written a book, and that is for all the usual reasons.
But more profoundly, I havne't written a book because I was never able to develop the theme that I wanted.

So, what was the theme that I failed to discover.
Well, as many travellers will tell you,  you should travel the world with your eyes open -- surely a good safety tip -- but what they really mean is, when you travel the world, be open to the ideas and expereinces you will ahve along the way, don't let your preconditions color your interpretations, don't got out into the world decidin gthat you already know all the answers.

So, what was my precondition when I tried to write this book ? What had I decided was the truth, and I just needed to find evidence of that.

In a word rules.

It is so common, as programmers for us to ask quetions like

what is the _right_ way to do something

When should I do X, and when should I do Y

A Go programmers, when should I use and interface, when should I use a concrete type

When should I use a function and when should I use a method

When shoudl I declare a method on a pointer, when should I declare a method on a value

What is the right way to handle errors.

And looking at my stack of notes I said to myself

"I think I can answer these questions, I'm going to write a book with the answers for Go programmers to these questions"

And I felt that it must be possible. I mean if Scott Meyers can write books about this for C++, Go, a much simpler langauge should be easy -- right ?

And to make a long story short, after months of writing and thinking and talking to people I realise that I had made a mistake.

And that mistake was, there are no rules that i can give to explain how I think GO programs should best be written.

In fact, the only rule I could come up with, after months of writing was

"It depends"

And it depends is something that as an engineer I say a lot, maybe you do as well.

David, what's the best way to handle uploads to our application

Well, it depends,

// [ and so on ]

And it's not that I'm being difficult, or non comittal, the it depends is always a prelude to asking questions about how they want to _use_ the thing that they have asked me to build.

And this here is the _essence_ of design. Design is about creating a solution that works without the constraints of the environment which it will be used.

Here in Tokyo for example I've seen a lot of these

// [ picture, tiny car ]

So, why are these popular here ? Why did someone design a car so specific for Tokyo ?

One answer is tokyo is very crowded city, small lanes, space is at a premium, so if you design a car with a smaller footprint, it will be easier to drive in Tokyo and easier to park.

So, coming back to It Depends.

What I realised working on this book is it is going to be difficult to come up with a set of rules that you can apply  to writing GO programs. And the clue there is really in the word

rules / patterns /  laws

these are all very concrete ideas, everyone must follow the rules, everyone must obey the law, you _should_ use this pattern when designing your software. IN fact, we have books giving 50 patterns that you can use.

But what I realised in the end is that the reader of this book is not looking for rules, or patterns, but advice.


In NN of 2015 Rob Pike gave a talk called "Go proverbs", hopefully many of you have seen it`. In this talk he outlined, in the theme of another book, also calle Go prbervs.

Who knows what a proverb is. It's a story, a very short story, that a master may say to his student, or a parent to a child. 

And part of the magic of a proverb is that there is a difference between knowing the proverb and known it's meaning. They are a guide to meaning.

So, today I'm going to talk about the Go proverbs, not all of them, we don't have time for that, and explain what they mean to me, and hopefully by expample, they will become clearer to you.

// https://en.m.wikipedia.org/wiki/Japanese_proverbs

* ことわざ

// kotowaza -- proverb

* 井の中の蛙大海を知らず

// Can someone read this for me ?
// Can you translate it for me ?

// a frog in a well does not know the great ocean

// i no naka no kawazu taikai o shirazu

// What is the story of the frog in the well ? What does it teach us ?

// If you are the frog in the well you may think you know it all, you know your small surrondings intimately, there are few who understand what it is to live in this well like you do.
// But, the world outside your well is vast in comparison, and your knowledge very limited

https://en.wikibooks.org/wiki/Chinese_Stories/The_frog_of_the_well

The parable of the Frog in the well is told in many countries, and many cultures. 
In Mao's China, the frog was a tyrant of the well.
In California they frog parable is referred to as the Blub Paradox. 

What are they all telling us; don't stop learning. Question your environment, question your assumptions, don't assume your right just because nobody has yet convinced you that you are wrong. 

* 井の中の蛙

// So if I say you to you all I no naka no kawazu, maybe some of you understand it, and those who do understand it not from the words "a frog in a well", but because you have learnt their meaning.

// You have to understand the meaning to understand the proverb.

== Go proverbs

https://www.youtube.com/watch?v=PAAkCSZUG1c

Last year Rob Pike gave a talked entitled "Go Proverbs", inspired by the english translation of this famous book by Segoe Kensaku

// http://senseis.xmp.net/?SegoeKensaku

In his talk, Sensei Pike asked

"Are there Go proverbs?"

* Go proverbs

https://go-proverbs.github.io/

The answer is yes, there are Go Proverbs, you may recognise some of them already

.Go proverbs
* Don't communicate by sharing memory, share memory by communicating.
* Concurrency is not parallelism.
* Channels orchestrate; mutexes serialize.
* The bigger the interface, the weaker the abstraction.
* Make the zero value useful.
* `interface{}` says nothing.
* `gofmt`'s style is no one's favorite, yet gofmt is everyone's favorite.
* A little copying is better than a little dependency.
* Syscall must always be guarded with build tags.
* Cgo must always be guarded with build tags.
* Cgo is not Go.
* With the unsafe package there are no guarantees.
* Clear is better than clever.
* Reflection is never clear.
* Errors are values.
* Don't just check errors, handle them gracefully.
* Design the architecture, name the components, document the details.
* Documentation is for users.
* Don't panic.

But just like the parable about the frog, rules are written down, but principals must be learnt

So how do we learn the principal's of software development? How do we gain the experience to judge ours designs with the eye of a master?

Simply, by study.

So today I want to talk about some of the proverbs, and explain what they mean to me, while talking about the features of go design that are important to me

My goal today is not to repeat Sensei Pike's words, I cannot do them justice.
Instead I want to talk about some aspects of the design of Go programs that are important to me and, where possible, relate these ideas to a Go proverb as I understand it.

==  Documentation is for users

Rob Pike is a great fan of documentation, you can see his influence in the language.
Have you ever had to write a manual for a program, maybe for a user, or for someone else using your library?
How long did it take before that document was wrong, because you'd changed something, or added a new feature, or the product made it to version 2.0 and you wrote a new user interface. 
I'm sure we've all experienced that, and have read documentation from other products that was out of date.

[quote, C. A. R. Hoare]
The readability of programs is immeasurably more important their writeability.

The source code is meant to be read, it will be read many more times than it is written

// http://i.stanford.edu/pub/cstr/reports/cs/tr/73/403/CS-TR-73-403.pdf

Documentation is more than the set of instructions that comes with your product. 
Who are the users of your code - everyone, you contributors, your libraries users, you API's users, your coworkers, even yourself. 
Documentation flows through everything, everything you write and how you write it should be descriptive and if possible self describing.

Functions should be commented to explain what they do, not how they do it.

Names of variables, should receive what they represent, not how they represent it.
A comment on a constant should not describe what the constant represents now how it should be used. 

A type should describe aht it provides, not how it provides.
And it should be placed into a file with a name that describes the purpose of if not contents of the file, not simply a manifest. 

So, avoid one type per file, because the name of the file ismply repeates the name of it's contents, that adds nothing, and overall detracts from the readability of your code. 

A package should describe what it provides, ot what it contains. 

Talk about example packages.
Good practice is to document each public symbol; method, function, constant, and type.
What if this practice was extended to document how to use the public types with examples.
Go gives us a great way to do this, with the testing helper, and integration into `godoc`.

In closing, if you cannot document it, do you understand it?

== Error handling 

Error handling is as important.
Error handling is as important as the rest of your code.
It's as important as checking a loop index for the exit condition, or checking the result of a shift operation, or testing the result of a multiplication is within the expected bounds, that's how fundamental error handling is to Go.
And, just like shifting or comparisions or multiplication, error handling is a first class responsibility of all Go programmers.
Because, you have to plan for failure.

Over the last 5 years of this blog I've written a lot about error handling. Because, error handling is important.

I've spent a long time thinking about the best way to handle errors in Go programs, but, probably unsurprisingly, have decided that there is no one true way to handle errors.
By the same token, error handling is not a spectrum of possibility.
Error handling techniques can be roughly classified into the three core strategies, which I will illustrate in this post.

With that proviso, I present, with apologies to Abraham Maslow, Cheney's hierarchy of error handling.
// [ image Cheney's hierarchy of error handling ]

Before continuing, I want to reiterate that I do not believe there is no one true error handling strategy that works for all conditions.
As the diagram, and this post will hopefully show, each error handling strategy involves a set of tradeoffs that you, the author, must manage.

=== Sentinel values

The first category of error handling is using sentinel values like io.EOF, or go/build.NoGoError. Low level errors like the syscall.Errno type also fall into this category. These sentinel values are compared by value, eg:

 n, err := r.Read(buf)
 buf = buf[:n]
 if err == io.EOF {
      return buf, nil
 }
 return buf, err

Using sentinel values is the least flexible of error handling strategy as client code is looking for equality with an exact value.
You cannot wrap a sentinel value with extra context, even a simple

 return fmt.Errorf("unexpected error: %v", err)

will defeat your caller's equality test.

Sentinel values are often associated with helper functions that inspect them, replete with complicated platform specific code to normalise cross platform differences.
A good example is this is the os.IsNotExist helper which is intimately aware of the ways a sentinel error value can be wrapped or smuggled inside another type.

If your public function or method returns an error of a particular value, it must be documented, and of course the value's definition must be exported.
This adds to the surface area of your API and counts against the complexity budget for using the package.

If your code implements an interface who's signature defines a specific sentinel value, all implementors need to import the package that sentinel value is defined.
More perniciously, if the interface method is defined to return a specific error value, all implementations are restricted to the vocabulary defined in the interface.

Sentinel values present a problem when you want to provide more context as they must not be annotated or wrapped by other error types.

=== Error types

Error types, as distinct from the previous error values, are more flexible. Error types, usually struct types, but of course any user defined type can implement error

Callers of a function or method can use a type assertion to check if the error value is a particular type, or preferably, the error value exposes specific behaviour by implementing a particular interface.

Returning an error of a particular type, rather than a value is more flexible. You can extend the information returned to the caller by adding fields to the type over time without.

The most important improvement of error types over error values is their ability to wrap an underlying error to provide more context in a programatic way.
An excellent example of this is the os.PathError type

Error types can also host methods unlocking the more powerful technique of asserting an error to an interface, rather than with a type assertion.
A counterexample to the previous os.PathError type, is the net.Error interface type, which defines behaviours that error values that types satisfying the other interfaces in the net package, like net.Listener and net.Conn.

=== Opaque errors

The most flexible error handling strategy, providing the least coupling between code and caller, is to treat the error value from a function or method as opaque. As the caller, all you know about the result of the function is that it worked, or it didn't.

If you can adopt this position, then error handling becomes significantly more useful as a debugging aid. You can now freely wrap or annotate errors with additional context

Opaque errors enable gift wrapping, which is a general version of the previous error type's methodology--except in this case you do not know the type you are asserting to.

Errors are part of your package's public API, treat them with as much care as you would any other part of your public API. Choosing how errors are communicated is the responsibility of the package's author and your decision impacts the usability of your package. Choose wisely.


- you shouldn't be using sentinal values
- you shouldn't be making up your own sentinals 
- you shouldn't use a sentinal in more than on place, because then you won't be able to track down where it came from 
- so, if you shouldn't use sentinals, and you shouldn't use them more than once, then you're better off treating the error as opaque and using errors.New("exact problem") every time.

=== Don't just check errors, handle them

Only handle an error once.

Handling an error means inspecting the error value, and making a decision.
You should always make one decision.
If you make less than one, you're ignoring the error.
This is clear.
But making more than one decision in response to an error is also a bad thing.

- annotate the error and return it, or
- log the error.

Do not do both.

=== Annotating errors

I'm going to talk a bit about how I add context to errors, and to do that I'm going to use a very simple `error` type.
This is example code, but libraries exist that do this properly.

The code is online at NNN, I'll just recap the API

    // Wrap returns an error value wrapping the 
    func Wrap(err error, msg string) error

    // Cause unwraps err, if possible, and returns the unwrapped error
    func Cause(err error) error


== communicate via sharing memory, is about ownership, talk about ownership, channels, rust and const

Even thought this was the first proverb we ever learnt about Go, published way back in 2009 [ link to blog ] I have chosen to leave it til last.

I have been studying Go for 6 years now and I must tell you that despite this being the first proverb I learnt about Go, it was the one that took me the longest to understand -- and even now I am not entirely sure that I truly understand its meaning.

Part of the difficulty I believe is that this proverb has mutliple meanings, it provides many lessons -- hence the confusion.

So, I will do my best to untagle it, and explain each of the meanings.



=== Communicate with data, not with messages

The first, and most obvious meaning of

[quote]
Don't communicate by sharing memory, share memory by communicating.

Is rather than sending signs between goroutines, send the data itself.

As an example, imagine if I wanted to send you a letter by mail, I would give the letter to the post office, who would then go to your house and leave a note in your letterbox telling you that there is a letter for you and you should come to collect it from your post office.

This would be quite annoying, they already came to your house, but instead of leaving the letter, all they left was a message for you to come and get the letter. 

So you go to the post office and show them the note that was left for you, but you have arrived to quickly, the letter is still in transit, so you have to come back later, which your letter is ready.

This is the sort of using locks and shared memory.

Rather than just send you the value, one goroutine told another that it was 

Talking about letters and post offices again, you can imagine how complicated this would be if I wanted to send everyone in my family a letter, not only would each of my family have to take the note to their post office to receive their copy of the letter, but some will arrive to early, and others may accidentally be given several copies of the letter by mistake, so other family members, no matter how many times they ask, will never receive their copy of the letter.

Back in the land of Go, this story is simpler. We can solve all the problems with locks and polling with channels. When a receive operation completes you don't just have the notification that a message is available, you have the actual data.

So this is one of the lessons of 

> Don't communicate by sharing memory, share memory by communicating.

That using channels to communicate between goroutines is much simpler, much easier to understand and reason about, than using locks, and shared memory.

== Ownership

But there are also other lessons that  

> Don't communicate by sharing memory, share memory by communicating.

has to teach us. 

The second lesson is about ownership of resources. There are many kinds of resources

- a value in memory
- a channel
- a file
- a network socket

And other types that you create in your own programs. But really it's the ownership of memory that is the most important, and this is because we live 
in a world where modern computers have 

=== Channel ownership

Channel ownership, who owns the channel, only the owner may close it.

You do not need to close a channel for it to be garbage collected, that will happen once every reference to your channel has been discarded.

Closing the channel is a signal, soem metadata apart from the channel values themselves

But the two are related, because most consumers wait for channel to be closed, and won't exit, thus drop their reference to this channel.until it is closed.

From this we draw two recommendations

. Only the owner of a chanel may close the chabel
. Never start a goroutine without knowing how it will stop.

== Interfaces

- interfcaes, when to use them, how to write them, when to use a method rather than a function -- to implement an interface.

== Proverbs are not rules

I've spoken a lot today about proverbs, and principals.
But I want to reinforce that this are just my opinions, and likely proverbs and not rules, principals are not rules.
Rules are like the laws of nature, the laws of physics.
You cannot disagree with the law of gravity.
You cannot disagree with the sign in the elevator that explains the maximum weight the elevator can safely carry.
You cannot disagree with the compiler about the syntax of a program, those rules are absolute.
But you can disagree with me, and you can choose at times when to disregard my advice
And in fact I encourage it, you sohuld

== Conclusion

I hope that this has been informative for you.

Proverbs are a great way of encapsulating information; capturing the essence of a story or teaching a moral. But they can equally be bewildering to newcomers who do not know the story behind the proverb.

I hope that you will watch Sensei Pike's video, I think it was a wonderful presentation and I cannot recommend it enough to each of you.

I hope that my explanations have been informative, and I will leave you to consider the meaning behind the other proverbs which I did not have time to discuss today.

And I will leave you with a proverb of sorts, not of my own, but one I think is appropriate

// http://english.stackexchange.com/questions/38837/where-does-this-translation-of-saint-exuperys-quote-on-design-come-from

[quote, Leonardo da Vinci]
Simplicity is the ultimate form of sophistication —Leonardo da Vinci

Thank you.

// https://en.wikipedia.org/wiki/Shibui

Shibui  渋い

I want to close, not on a proverb, but on a beautiful word that I discovered in my research.

And I like this word, because if there is a word which I think properly describes my feelings about Go, it is Shibui. 

An restrained design, functional without a course agrecultural design.


High performance servers without the event loop
OSCON, Portland
21 Jul 2015

Dave Cheney
dave@cheney.net
http://dave.cheney.net/
@davecheney

* Abstract

Conventional wisdom suggests that high performance servers require native threads, or more recently, event loops.

Neither solution is without its downside. Threads carry a high overhead in terms of scheduling cost and memory footprint. Event loops ameliorate those costs, but introduce their own requirements for a complex callback driven style.

A common refrain when talking about Go is its a language that works well on the server; static binaries, powerful concurrency, and high performance.

This talk focuses on the last two items, how the language and the runtime transparently let Go programmers write highly scalable network servers without having to worry about thread management or blocking I/O.

The goal of this talk is to introduce the following features of the language and the runtime:

- Escape Analysis
- Stack management
- Processes and threads vs goroutines
- Integrated network poller

These four features work in concert to build an argument for the suitability of Go as a language for writing high performance servers.


* Introduction

I got into Go because it offered performance.

As a BOFH in a past life the most stressful times in my career were defined by unstisfying performance.

While there were other aspects of the language that appealed to me; minimalism, simplicity, orthogonality; it was the performance that was the deciding factor.

Go is a general purpose language currently in use in a wide range of application domains. But if we look back to 2009, to the introductory material specificaly mentions "a language for solving problems of Google's size -- and Google has large problems".

-- And that means, "writing servers"

This then is the subject of my talk, features of the Go language and runtime environemnt that (mostly) transparently to the programmer allow you to write high performance servers with simple, structured programming, code.


* Topics

- Escape Analysis
- Stack management
- Processes, threads, and goroutines
- Integrated network poller

* Escape analysis

Allocation

- How many bytes, what is the footprint, per connection, per client, per request ?


* Conclusion

All of these features are (mostly) transparent to the programmer.

Go lets you write high performance servers with simple, imperative, code.

The langauge and the runtime take care of handling blocking i/o.





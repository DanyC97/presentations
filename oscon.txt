* About me


* Credentials

- BOFH for many years
- Yelling at the cloud since 1998
- automation before it was puppet
- transitioned to Go programmer 5 years ago

* Agenda

- History lesson, part i
- An argument for an efficient programming language
-- cpu history
- History lesson, part ii
- An argument for a concurrent programming language 
-- c10k history
- Go is this language, let me show you why
- You have to be internet scale from the start.

* network servers

what does a fast general purpose language mean ?

not gene folding

not HPC

not desktop gaming

not bitcoin mining

you need a language which is compiled, because interpreted languages just do not justify themselves in production, at scale, on a capex basis




* Moore's Law

The oft mis quoted Moore's law states that the number of transistors per die (waifer?) will double every 18 months.

However clock speeds, which are a function of entirely differnt properties topped out a decade ago with the Penryn generation ~ 3.5Ghz and have been slipping backwards ever since

Over the last decade, 

- data centers have moved from space constrained, you could fit e450's in a full height rack, to power constrained. The last two data center rollouts I did, we ran out of power when the rack was barely 1/3rd full
- being power constrained has effects at the macro level; can't get enough power for your 700 watt 1RU servers, as I showed above, and at the micro level -- all this power, hundreds of amps at very low voltage is being dissipated in microscopic cpu die.

* Where does this power consumption come from ?

CMOS switching, CMOS stands for _complementary_ metal oxcide semiconductor, the _complementary_ part is the key. Digital logic inside a CPU is implemented with pairs of transistors

https://www.ece.cmu.edu/~ece322/LECTURES/Lecture13/Lecture13.03.pdf

* Right, thank's for the non sequitor

What's the point of this background ? The point is, while an argument that moore's law is still in effect, for the people in this room, the free lunch is over

CPU's process size shrink are now primarily aimed at reducing power consumption; this gives longer battery life in laptops, lower power consumption in desktop and server parts. And when I say lower, we're not talking about "green" here, we're talking about keeping power consumption, and thus disipation below levels that will damage the cpu.

Performance increases come mainly from small microarchitecture tweaks, an escoteric vector instructions which are not useful for the 

Added up, each _microarchitecture_ (5 year cycle) change yeilds at most 10% improvement, and most recently 4-6%.

* What's your point ?

So, why am I rambling on to you about hardware at a software conference ? 

It is clear to me, and hopefuly clear to you now, that hardware is not getting any faster. The old addages that a slow langauge doesn't matter 'cos in a few years hardware will be x times faster do not apply anymore.

If performance and scale is important to you, and arguably it is, as you're here in this session, then you'll agree with me that the days of throwing hardware at the problem are over - at least in the convention sense.

The arguments 'ruby, performance doesn't matter, it's the web' are also busted

If you care about performance, you need a langauge which produces efficient programs on the server.

but with clock speeds fixed, and in direct conflict to total thermal wattage (TDP), achtectural improvements to the core of the cpu, have given only 10% improvements by microachictecture (one every 5 years), and recenly as little as 4-6%

Now, in this talk I'm going to argue that Go is this indeed this langauage, but you'd be right in thinking that there are pleanty of other existing langauges which produce efficient excutables.

- Traditionally C
- More recently C++, especially after C++ 0x11
- Jitted languages like Java and Javascript (v8)

To explain why I think Go is a better choice than these languages, on the server, I need to come back to 

* CPUs are not getting faster, but they are getting wider

So, CPUs are not getting faster, but they are getting wider, that is to say, hyper threading, dual core (mobile i5/i7) , quad core (desktop i5/i7), oct core and more (xeon)

* internet scale

need to plan to be internet scale from day one.

- microservices
- redundant
- distributed
- efficient

* Your grandfathers server

e450 

dialup modems

disk io was the main factor, network io was slower than disk seek times, so raid volumes worked well, and machines like the e450 were workhorses

http serving was apache, apache, apache, and apache 1.3 btw.

prefork was the name of the game

dan keegle's 10k challenge

threaded servers, still one connection per 

* Introducing Go, in two slides

Hopefully some of you in the room have seen or tried Go. If you've been dabbling in Docker, CoreOS, or Kubernetes, it's probably been unavoidable for you.

I'm going to give a 2 slide overview of Go. If you're interested in learning more about the language, I believe the confernce has organised a workshop series on Go, if you would like to know more, I'll be around all week, so come and find me.

- C style language, with curley braces, but no semicolons
- Imperative style
- Not class based, there is no inheritence, instead we have composition and interfaces
- Key features
-- lightweight concurrrency through goroutines
-- intraprocess communication by way of channels, typed queues that can be used to pass information or synchornise between goroutines.

* Goroutines

* Stack mangement

* Stack growth and shrinkage

* Heap management through escape analysis

Concurrent, low pause collector, in Go 1.5, but creating garbage will never be free (hint: it's not free with malloc or reference counting either), so you want to avoid that where possible to manage your alloations up front.

* Escape analysis

blah blah

* Inlining

- reduces funciton call overhead
- reduces the pressure on the stack allocator 
- enables better code motion invariants, dead code elimination, common sub expression elimination, etc

* Integrated network poller

- I showed:

you _need_ a langauge which is concurrent from the start

and you need a language which is memory efficient, because while concurrecny can be simulated with threads, to hold up an internet's work of traffic you cannot dedicate megabytes of ram per incoming connection, lest your business is dragged under by hardware and overheads.



* But wait, there's more

As this is the performance track, i've mostly constrained my remarks to this area, but there is a lot more to the Go success story than just being fast, and these are arguably the more notable features of the language

- Super fast compilation
- Excellent tooling
- Excellent cross platform support, cross compilation as well without tears
- Ridiculusly simple deployment story, scp(1) and you're done -- not runtime interpreter like python, ruby, php, java, etc. Single static binary

if you want to write software that supports the entire internet, it is no long possible to do that with a single monolithic application -- there just isn't a machine that you can buy that is large enough

So, if you're planning on your application being successful, then it needs to be composable from day one

I look ascanse at the topic of microservices, in the same dim view that I looked at Big Data in 2014 when everyone was loosing their shit.

With that said, any succesful consumer facing web business is going to be decomposing their application, and that decomposition is a market that Go serves very well.

Simple deployment story
Simple conventions
Excellent network and concurrency support

* Stop, question time

* Thank you



= SOLID Go design
Dave Cheney <dave@cheney.net>
v1.0, 3rd May, 2016

== Introduction

Good morning and thank you for coming to my talk.

My name is David, I'm a Go programmer from Sydney, and I'm delighted to be able to talk about Go at a technical conference here in my home country. 

Before I begin I must note that, compared to the decades of experience of my fellow speakers, I feel like somewhat of an interloper at this conference.
Although a keen amature since childhood, I arrived at the software development profession late in life.
My own career, until recently, was focused on what we now call operations.
So I ask that you do not view me as an expert, at best, a peer.

== Introducing Go

[quote, Alan Donnovan and Brian Kernighan, The Go Programming Language]
The Go project includes the language itself, its tools and standard libraries, and last but not least, a cultural agenda of radical simplicity.

My interest in Go is a response to the language's fresh approach to the problems of large scale software development.

Go is a young language.
We celebrated the 4th birthday of the 1.0 annoucement footnote:[http://blog.golang.org/go-version-1-is-released] just over a month ago. 
Go is a member of a triumvirate of modern langauges, Rust and Swift being the other two, that together represent a return to programs compiled directly to machine code.
All three are memory safe, concurrent, and without the requirement for a runtime, such as a virtual machine, or interpreter.
All three languages represent a movement away from the __everything is an object__ paradigm popularised by Ruby and Java.

Go is not an academic langauge.
Go is a language that is explicitly designed for programming _in the large_.
Its design is influenced heavily by the needs of its patron, Google.
Go is a language which is designed primarily for the productivity of programmers, plural.

I work on two large Go projects, the first is the Go language itself, the second and more capacious is Juju, from Canonical, who I am grateful for sponsoring me to attend this conference. 

// image of go project LOC, Juju LOC

One aspect of dealing with projects of this size is there is more to debate than the minutiae of variable names, file layout, and the correct number of spaces after the period--not that these subjects are immune to heated debate.

This is not to imply that design is not important for smaller programs.
Personally I think we should aim to always write smaller programs, but the realities of commercial software development occasionally impinges on this idealistic world view.
Design is important for programs of all size, but as the size--and age--of a projet grows, it becomes paramount.

As authors such as Sandi Metz, Robert Martin, and the late Jim Weirich remind us, the only constant in software development is change.
To believe in a world where software is _done_, in perpetuity, is to believe in a fantasy.

== SOLID Go design

In his book, Agile Software Development: Principles, Patterns, and Practices,footnote:[Pearson, 2003] Robert Martin introduces a series of ideas as the cornerstone to the construction of software that is amenable to change.
Martin later codified these as the SOLID principals in a 2006 article entitled __Principals of Object Oriented Design__footnote[http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod] and a series of what we would now call, white papers.

Part of a larger set of design principals, the SOLID principals are closely associated with the object oriented languages of their time, C++, Java, and C#.
Although they span different eras all three share the same class structured, inheritance based, foundation. 

This talk focuses on the interpretation of Go programs according to Martin's SOLID design principals.
It is not a theological deconstruction of the principal's themselves.
In effect, I hold them to be self evident, as hopefully do you as indicated by your presence here today.

== Will it blend?

The hallmark of Go's design asthetic is simplicity.
One of the visible signs of this drive towards simplicity is Go's abandonment of traditional class based inheritence.
In fact, Go supports no forms of inheritence.

After the inital excitement of C++, and the cold reality of inheritence in commercial C# and Java programming, Go's abandonment of inheritence apprears prescient.
Not only did this side step the quagmire of multiple inheritence, it comitted the language firmly to the paradigm of composition.

Does this mean then that Go programs cannot follow the SOLID design principals, or that Go is not an object oriented language?
Let us investigate.

== Single responsibility principal

Let's open with the single responsiblity principal.

[quote, Robert C. Martin]
A class should have one, and only one, reason to change.

Why is it important that as a unit, a piece of code should have only one impetus for change?
Why should a programmer care about this level of taxonomy?
Because as destressing as the idea that your own code is changing, it is far more distressing that code your code depends on changed under foot.

When your code does change, it should do so in response to a direct stimuli, it shouldn't be a victim of collatoral damage.
Change can be compartmentalised, making changes more targeted, and as a result, limiting the blast radius.
Therefore code that does one thing has less reason to change.

Two pieces of code that are highly sensitive to change in their counterpart are said to be tightly coupled.
Coupling is simply a word that describes two things moving together, a change in one induces a change in another

In electrical engineering, inductive coupling describes the change in an alternating current in one winding of a transformer inducing a voltage in the other.
In nature, trees bend in the wind because they are coupled to the motion of air moving across their branches.

Uncle Bob's imperative single responsibilty principal is a derived from a much older observation by Tom DeMarco.
In his book Structured Analysis adn System Speficiation footnote:[http://www.amazon.com/Structured-Analysis-System-Specification-DeMarco/dp/0138543801] DeMarco puts forward a description of software cohesion.

[quote, Tom DeMarco, Structured Analysis and System Specification]
____
Cohesion is a measure of the strength of the association of the elements inside a module.
A highly cohesive module is a collection of statements and data items that should be treated as a whole because they are so closely related.
Any attempt to divide them would only result in increased coupling and decreased reability.
____

The word _cohesion_, in the context of software, is the property of describing pieces of code are naturally attracted to one another.
They stick together, like the poles of magnets, and so where one goes, the other follows.

=== The Go package model

To describe the units of change in a Go program, we start with the package model.
In Go all code lives inside a package, even the main function--which we call, not surprisingly, the main package.
In this package deliniated world, the units of change are primarily those a externally visible to a package.

Go packages are compose of various elements; constants, variables, types, functions, and methods.
Each of these can be either public or private, and true to Go's focus on simplicity, a symbol is private unless its name starts with an upper case letter.

=== Package names

Each package has a name, which is

The use of another package's symbols inside your own is acomplished by the `import` declaration

=== Unix reincarnated

No discussion of Go, or decoupled design in general, would be complete without mentioning Doug McIlroy.

In 1964 Doug McIlroy postulated about the power of pipes for composing programs.
This was five years before the first Unix was written mind you.

[quote, Doug McIlroy, Quarter Century of Unix, Salus et al]
This is the Unix philosophy: Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface.

McIlroyâ€™s observations became the foundation of the UNIX philosophy; small, sharp tools which can be combined to solve larger tasks.
Rasks which oftentimes may not have been envisioned by the original authors.

Go programs embody the spirit of the UNIX philosophy.
In effect each Go package is a self contained Go program, with access to the entire language.
Go packages interact with one another via interfaces.
Programs are composed, just like the UNIX shell, by combining packages together.

== Open / Closed principal

In is 1988 book, __Object-Oriented Software Construction__, Bertrand Meyer defined the Open / Closed principal.

[quote, Bertrand Meyer]
Software entites should be open for extension, but closed for modification.

The open closed principal states that classes should be open for extension, but closed for modification.
Go does not have classes, but we do have structures, and methods on types.

Here is an example
----
type A struct {
	v int
}

func (a *A) Value() int { return a.v }
----

The type `A` has a method `Value` which returns the contents of `v`.
This is a not a particuarly useful piece of code.
----
type B A
----
We also have a type `B` which shares the same underlying type as `A`.
Note that `B` does not extend `A`, nor is `B` derived from `A`.
Both `A` and `B` share the same underlying type, a structure with one integer field, `v`.
----
struct {
        v int
}
----
Sharing the same underlying type means that values of type `A` can be copied to type `B` other because ultimately as they share the same layout in memory. However, the method set of `B`'s is distinct from `A`, in fact in this example it's empty.
----
var a A
a.v = 100
fmt.Println(a.Value()) // prints 100

var b B
b.v = 200
fmt.Println(b.Value()) // b.Value undefined (type B has no field or method Value)
----
If we want B to have A's methods not just it's fields, we can instead do this.
----
Type A struct {
     v int
}

func (a A) Hello() {
	fmt.Println("Hello YOW!West %d", v)
}

Type B struct {
     A
}

func main() {
	var a A
	a.v = 2014
	var b B
	b.v = 2015

	a.Hello() 
	b.Hello()
}
----
In Go we call this pricatice _embedding_.
In this example type `B` has a `Hello` method because `A` is embedded into `B`.

It is as if by embedding `A` into `B` the compiler had provided the following  _forwarding_ method for us (which is not far from the truth).
----
func (b B) Hello() {
	b.A.Hello()
}
----
But embeddeding isn't just for methods, it also provides access to an embedded type's fields.
As you saw above, because both A and B are defined in the current pacakge, we can even access `A`'s private fields as if they were defined in `B`..

=== No virtual dispatch

Embedding allows Go's types to be open for extension.
A caller will see `B`'s methods overlayed on `A`'s because `A` is embedded, as a field, within `B`.

However `A` is never aware that it has been embedded into `B`, there is no mechanism for `B`'s methods to override `A`'s. 
----
type Cat struct {
	Name string
}

func (c Cat) Legs() int { return 4 }
func (c Cat) CountLegs() {
	fmt.Printf("I have %d legs\n", c.Legs())
}

type OctoCat struct {
	Cat
}

func (o OctoCat) Legs() int { return 8 }

func main() {
	var octo OctoCat
	fmt.Println(octo.Legs()) // 8
	octo.CountLegs() // actually octo.Cat.CountLegs()
}
----
In this example we have a `Cat` type which can count its number of legs with its `Legs` method.
Now, we embed this `Cat` type into a new type, an `OctoCat`, and decare that octocats have eight legs.

But, even though OctoCat defines it's own `Legs` method which returns 8, when the `CountLegs` method is invoked, it returns 4.

This is because `CountLegs` is defined on the `Cat` type, so it dispatches to `Cat`'s `Legs` method.
`Cat` has no knowledge of the type it has been embedded inside of, so its method set cannot be altered by embedding it.

Thus, Go's types are closed for modification.

=== This is not inheritence

This is a not a wacky way of doing inheretence in Go.
There is no implicit _this_ parameter in Go.
The recevier is exactly what you pass into it, the first parameter of the function. 
And because funcions are _not_ polymorphic, B is not substitituable for A.

In truth, methods in Go are little more than syntactic sugar around calling a function with a predeclared formal parameter, the reciever. 
----
func (s *Speaker) SayHello(name string)
----
Is just syntactic sugar for
----
func Hello(s *Speaker, name string)
----
And this brings us to the next principal.

== Liskov substitution principal

Coined in by Barbara Lisvok in her 1988 keynote address to the ACM SIGPLAN conference, the Liskov substitution principal states, roughly, that two types are substitutable if they exhibit behaviour such that the caller is unable to tell the difference.

In a class based language, this is commonly interpreted as a specification for an abstract base class with various concrete implementations.
But Go does not have classes, or inheritance, so substitution cannot be implemented in terms of an abstract class.

As we saw above if you have a type
----
type B struct {
	A
}
----
And a function that takes an `A`
----
func update(a *A)
----
You can, assuming the types are public, pass a pointer to `B.A` to the `update` function.
----
var b B
upate(&b.A)
----
The embedded `A` structure inside `B` is unaffected by the fact it is part of the larger `B` structure, just as values in memory are unaffected by their neighbours.
But this isn't really substitution.

=== Interfaces and behaviour

Subtituion in Go is the pervue of interfaces.

While Go's packaging system draws strongly from Modula-2, and it's successor Oberon, the design of Go's interfaces are likely influenced by Python's protocols, a legacy from the environment where Go was born. 

Types are not required to nominate, either by an `implements` declaration or by extending from an abstract type, that they implement a particular interface. 
In Go, _any type_ can implement an interface provided it has all the methods whose signatures matches the interface declaration.

While it is not possible to modify a type from another package, at any time an interface may be defined, and if a type satisfies the interface, then automatically that type  _is_ an implementation of the desired interface.
We say that in Go interfaces are satisfied implicitly, rather than explicitly, and this has a profound impact on how they are used in the language.


=== Small interfaces

Well designed interfaces are more likely to be small interfaces; the prevailing idiom here is that an interface contain only a single method.

Compare this to other languages like Java or C++, whose interfaces are generally larger.
Larger in terms of both the method count required to satisfy them, and complexity because of their entanglement with the inheritance based nature of those languages.

Interfaces in Go share none of those restrictions and so are simpler, yet at the same time, are more powerful.
Any Go type, written at any time, in any package, by any programmer, can implement an interface by simply providing the methods necessary to satisfy the interfaceâ€™s contract.

It follows logically that small interfaces lead to simple implementations, because it is hard to do otherwise.
Leading to packages comprised of simple implementations connected by common interfaces.

A canonical example of small interfaces are found in the io package.
----
type Reader interface {
	Read(buf []byte) (int, error)
}

type Writer interface {
	Write(buf []byte) (int, error)
}

type Closer interface {
	Close() error
}
----


=== Interface composition

In Go, we often compose interfaces from smaller ones.
For example, an interface which encapsulates the behaviour of a type returned from the `os.Open` function might be.
----
type File interface {
	Read([]byte) (int, error)
	Write([]byte) (int, error)
	Close() error
}
----
Just as we saw above, two types can be considered equal when they have the same set of fields, two interfaces are equal when they have the same set of methods.
And similar to type embedding, Go supports interface embedding, allowing the previous declaration to be rewritten as
----
type ReadWriter {
	io.Reader
	io.Writer
}

type ReadWriteCloser {
	ReadWriter
	io.Closer
}
----

=== Design by contract

Go does not have anything like Eifel's design by contract, but we do have interfaces.

[quote, Jim Weirich]
Require no more, promise no less

So the pull quote for LSP could be summarised by this lovely aphorism from Jim Weirich.
And this is a great segue into the next SOLID principal.

== Interface segregation principal

At this point in the presentation, hopefully you'll agree with me that in Go, types describing data, and interfaces describing behaviour.
Interfaces define the behaviour of various components, types provide the implementations.

As Go's interfaces are satisfied _implicitly_, it is not the implementation that dictates which interfaces it implements, that privilege belongs to the consumer.

[quote, Robert C. Martin]
Clients should not be forced to depend on methods they do not use.

The interface specification says that clients should not be forced to depend on irrelevant parts of an interface.
And when Martin talks about interfaces, he's making a broader defintion than the one I just described in Go.

So if I was writing a function that wanted to work on file like things, I could specify it to take an `*os.File` like this
----
func WriteUserConfig(f *os.File, cfg *Config) error
----
But that would be unpleasent to test, as I would have to ensure that f was written to a temporary location, and always removed afterwards to avoid filling up `/tmp`.
Secondly, because this function only works with files on disk, to verify its operation, the test would have to read the contents of the file after being written.
Thirdly, this signature precludes the option to write the user's config file to a network location, unless it was previously made available as a network share.
Finally, assuming that network storage was a requirement later, the function of this signature would have to change,

- close the file externally
- make deleting the partial file on failure the responsibilty of someone else, SRP.



Highly cohestive interface types have methods which are directly related to the operations -- towards a _single_ goal (SRP), 

You can spot poor interface declarations, they're usually the ones with a large number of methods.
The other sign is in many of that interface's implementations,  methods will be stubbed out, and things will be just fine--in tests and in production.

You don't know why you need these methods, but you have to have them -- because that's what the interface's contract requires.
These are the beurocracy of your interface.

An example of this comes from the net.Conn interface.
net.Conn conceptually extends an io.Reader/Writer/Closer with methods for retrieving the local and remote addresses for this network connection, and because this is the network, setting deadlines.
So, this is the final definition for net.Conn

Show the net.Conn interface as an example of both a good, and bad design.

- Show type switches to _safely_ upgrade to a more comprehensive interface. Warn against type switch against a concretetype. 
- A type assertion from one interface type to another exposes more behaviour
-- Show how to do this in Go.
- A type assertion from an interface type to a concrete type moves you from talking about 


The ideal interface has exactly one method, and that ties back to SRP.

Talk about interface / func duality.

Go has first class functions, so consider instead

== Dependency inversion principal

// Functions should do one thing. They should do it well. They should do it only.

[quote, Robert C Martin, (2003). Agile Software Development, Principles, Patterns, and Practices. Prentice Hall. p. 127-131. ISBN 978-0135974445.]
____
A. High-level modules should not depend on low-level modules. Both should depend on abstractions.
B. Abstractions should not depend on details. Details should depend on abstractions.
____

[quote, Robert Martin by way of Jim Wierich]
Depend upon Abstractions. Do not depend upon concretions.


Also, 1996 C++ report, and 1994

This is the dependency inversion principal, not dependency injection, or worse, a dependency injection _framework_.
This is also not inversion of control; although this was part of the original DIP paper.
Fortunately the industry has abandoned the notion of this kind of metaprogramming.

What is a concretion, and how does one invert ones' dependency on it.
What does DIP mean in practice for Go programmers?


As Go supports both functions and methods on types, you can implment not just singleton's, but plan old functions.
A function is a constant who's value is the entry point to the function.
As it's a constant, obviously it cannot be changed, and that shows itself often when writing tests.

Go does not have constructors.
Instead we encourage Go programmers to make use of the type's zero value; that is, the interpretation of the type's fields if the memory that underlies them were zero.

But it is com

Clients, functions and methods that take values, should depend on interface types, and those interfaces should be as narrow as possible.
This reduces, possibly eliminates, their coupling to the concrete implementation they are provided at run time.

A public function in a commonly used package is a very tight source level dependency.

=== Pure functions

One obvious difference from Go's __everything is an object__ predecessors is it's support for first class functions and lexical closures.

Go functions are not pure, not in a functional programming sense of the world, but you should act as if they are anyway.
Eschew global state, pass all the values requred into the function.

=== Implicit interfaces

So far we've discussed that methods and functions should operate on parameters declared as interface types.
This decouples the consumer from the implementation details of the value it is passed and allowing the user of those methods to reuse the functionality of that code by substitituing many implementations.

A great example of this is the `io.Copy` method from the `io` package.
----
func Copy(w io.Writer, r io.Reader) (int, error)
----
`Copy` reads from a reader until it is exhausted, and writes that data to a writter.
When complete it returns the number of bytes transfered, and if the trasnfer ended normally, or abnormally.

Packages should interact using interface values, rarely concrete types.
Those interface values can be defined by the caller, or the callee.

// Show Weirich's diagram of A, B, C, D pointing to E

A change to this

- talk about how interfaces are satisfied impllicitly, at compile time.
-- Talk about interface equality, and that the consumer of a type defines the interface it expects. 
-- This breaks the source level dependncy on the _interface_.
-- Talk about implicit interfaces
- talk about how interfaces can be defined by the caller
-- Bonus: in Go, interface's are implemented implicitly. Which means you no longer need to import a package to ensure you share the same interface definition. In Go, interfaces types are equal if their method sets are equal, and as we saw earlier one can define a smaller interface (fewer methods)

Talk about single method interfaces being substituable for functions.

Give example from http class that takes bufio.Reader, talks about how that limits us.

You want to depend on things that cannot change, and those are the _interfaces_ not the implementation -- because software changes, that is it's nature

Talk about direct dependency, with uml, talk about depedning on an interface instead, breaking the direct depdenency.

Use the thermostate example from here https://youtu.be/dKRbsE061u4?t=1373

Talk about returning _concrete_ types, not interface types. Show standard lib examples.

Talk about type switches on interface values, talk a little about errors

Talk about behaviour vs implementation.

== A theme

Each of Martin's SOLID principals are powerful ideas in their own right, but taken together they have a central theme; dependency management.

Martin's observation is all five of the SOLID principals relate to managing the dependency between software units.
The dependencies between functions, the dependencies between types, the dependencies between modules.
Which is another way of saying "decoupling"
And this is indeed the goal, because software that is loosely coupled is software that is easier to change.

On reflection, SRP and OCP are really the same thing in Go; embedding.
LSP, ISP, and DIP are facets of the way your design your program using Go's interfaces.

LSP encourages you to move the declaration of the things your code expects from the source level--in Go we see this with a reduction in the number of  `import` statements--to runtime.
This is crucial because if the code is written to expect _anything_ that implements a certain interface, a certain behaviour--behaviour that the code defines--not imports from somewhere else.
Somewhere shared, then _any_ conforming implementation should work.

How can we be confident that any implementation will work?
By making the interface smaller.
This is ISP, and in Go the strong drive is to create interfaces that expose only a single behaviour.

If your type only needs to implement a single interface method, then it is more likely to have only one responsibility.

And lastly, just as you can compose types, you can compose interfaces, and while the implementations that conform to this larger interface my be more complex, the code that uses them, by virtue of _requiring_ only the behavoiur it cares about can do something _awesome?_.

Go was explicitly built to control source level depenendenices.

== One more thing

If you were to summarise this talk as an elevator pitch it would probably be; interfaces let you apply SOLID principals to Go programs.
Interfaces in Go are therefore a unifying force; they are _the_ means of describing behaviour.
Interfaces let programmers describe what their function, method, or package provides--not how it does it.
This shouldn't really be a suprise, as interfaces provide polymorphic dispatch, which is really the core of object orientation.

But before I close, I want to mention one thing which is generally overlooked by speakers, like myself, prostelitising SOLID principals.
That fact is Martin's original article listed 11 principals.

// image http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod

In addition to the five SOLID principals, describing class design and class relationship, Martin went on to describe six more design principals, which it turns out also apply to the construction of Go programs.

=== Package composition

The sixth, seventh, and eighth principals are

CCP, the Common Closure principal. 
Classes that change together should be grouped together.

In well written Go programs, packages are usually larger than you would find them in languages like Java or C#.
A package, and hence a package's name, describes its purpose, _not_ its contents.

You shouldn't find a `server` package, or a `client` package, but you will commonly find an `smtp` package or a `http` package.
Which leads into the next principal

CRP, the common reuse principal, states that classes which are used together are packaged together.
While Go packages live on disk in a tree of directories, this does not confer a package hierarchy.

Talk about helpers, parsers and such being part of one package, rather than being placed in their own package.
A package should provide a complete solution.
If a package is incomplete or inoperative without the use of types from another package.
That is, those packages are always found used together, and never apart, then they fail the CCP and CRP designs and should be merged.

=== Package cohesion

The final three principals are

ADP, The Acyclic Dependencies Principle
The dependency graph of packages must have no cycles.

A language which permits a cyclic dependency graph, such a java is significantly harder to compile.
Go sensibly does not permit cycles in a package's dependency graph, which are colloqually known as an _import loop_.
Finding oneself in the position that code will not compile because of an import loop is prima facie evidence of a design defect.

SDP	The Stable Dependencies Principle	Depend in the direction of stability.



SAP	The Stable Abstractions Principle	Abstractness increases with stability.

The final principal, as types are referenced further from their defintion, they tend to be described more abstractly.
Accepting a network connection, for instance will return you will receive a concrete type that implements the `net.Conn` interface.
A handler that services that request may not need to know that this is a network request and can accept the value as an implementation of an interface that offers on Read, Write and Close behaviours.
Further still, the various parts of the handler will be concerned only with reading the request, or writing a response and so can treat the value as something that is only Readable or Writable, respectively.

== In Closing

[quote,Sandi Metz]
Design is the art of arranging code that needs to work _today_, and to be easy to change _forever_.

The SOLID principals are a tool to talk about design.
They aren't rules, like the rule of law, or the law or gravity.

Rules do not need a context, it doesn't matter how important it is to you, wooden bridges are not as strong as steel ones.
Principals need a context. 
Stop talking about rules for software development, talk about principals.
Be true to your principals, it's ok to bend once in a while, but don't abandon them.

Don't forget, the goal is to write software that is amenable to change.
Because a design that is so intricate that it cannot be changed is obsolete before you've finished implementing it.

Thank you.

----

// In Go a type and the method set of that type are orthogonal.
// Methods may declared on any type that you declare in your packaged.

- require interfaces, return unexported concrete types.
- focus on depending only on behaviour.

----
A function which performs some kind of control of a bank balance _and_ updates performance counters is _not_ cohesive.
Maintaining a bank balance, and recording metrics about how frequent or how long a request took are seprate concerns.

Alternatively a group of methods on a Complex datatype, providing addition, division and so on _are_ indeed cohesive, they all relate to the maintanence of that type.
If you are responsible for doing more than one thing, then you at some point one or more of those responsibilities will change.

----
- talk about adding methods to any type that you own
- talk about public and private symbols
- if you don't own a type you cannot add a method to it
- if you a type, or one of it's fields are not exported, you cannot access it to modify its state.

=== Method resolution

https://play.golang.org/p/ALIexlJV-T



= SOLID Go design
Dave Cheney <dave@cheney.net>
v1.0, 3rd May, 2016

== Introduction

Good morning and thank you for coming to my talk.

My name is David, I'm a Go programmer from Sydney, and I'm delighted to be able to talk about Go at a technical conference here in my home country. 

Before I begin I must note that, compared to the decades of experience of my fellow speakers, I feel like somewhat of an interloper at this conference.
Although a keen amateur since childhood, I arrived at the software development profession late in life.
My own career, until recently, was focused on what we now call operations.
So I ask that you do not view me as an expert, at best, a peer.

== Introducing Go

My interest in Go was sparked in 2009 by the language's fresh approach to the problems of large scale software development.

Go is a member of a triumvirate of modern languages, Rust and Swift being the other two, that together represent a return to programs compiled directly to machine code.
All three are memory safe, concurrent, and without the requirement for a runtime, such as a virtual machine, or interpreter.
All three represent a movement away from the __everything is an object__ paradigm popularised by Ruby and Java.

Go is a young language.
We celebrated the 4th birthday of the 1.0 announcement footnote:[http://blog.golang.org/go-version-1-is-released] just over a month ago. 

Go is not an academic language.
Go is a language that is explicitly designed for programming _in the large_.footnote:[https://talks.golang.org/2012/splash.article]
Its design is influenced heavily by the needs of its patron, Google.
Go is a language which is designed primarily for the productivity of programmers, plural.

I work on two large Go projects, the first is the Go language itself, the second and more capacious is Juju, from Canonical, who I am grateful for sponsoring me to attend this conference. 

TODO image of go project LOC, Juju LOC

One aspect of dealing with projects of this size is there is more to debate than the minutiae of variable names, file layout, and the correct number of spaces after the period--not that these subjects are immune from heated debate.

This does not to imply that design is not important for smaller programs.
Personally I think we should aim to always write smaller programs, but the realities of commercial software development occasionally impinges on this idealistic world view.
Design is important for programs of all size, but as the size--and age--of a project grows, it becomes paramount.

As authors such as Sandi Metz, Robert Martin, and the late Jim Weirich remind us, the only constant in software development is change.
To believe in a world where software is _done_, in perpetuity, is to believe in a fantasy.

== SOLID Go design

In his book, __Agile Software Development: Principles, Patterns, and Practices__footnote:[Pearson, 2003], Robert Martin introduces a series of ideas for the construction of software that is amenable to change.
Martin later codified these ideas as the SOLID principals in an article entitled __Principals of Object Oriented Design__footnote:[http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod] and a series of what we would now call, white papers.

Part of a larger set of design principals, the SOLID principals are closely associated with the object oriented languages of their time, C++, Java, and C#.
Although they span different eras all three share the same class structured, inheritance based, foundation. 

This talk focuses on the interpretation of Go programs according to Martin's SOLID design principals.
It is not a theological deconstruction of the principals themselves.
In effect, I hold them to be self evident, as hopefully do you as indicated by your presence here today.

== Will it blend?

[quote, Alan Donnovan and Brian Kernighan, The Go Programming Language]
The Go project includes the language itself, its tools and standard libraries, and last but not least, a cultural agenda of radical simplicity.

The hallmark of Go's design aesthetic is simplicity.
A prominent sign of this drive towards simplicity is Go's abandonment of traditional class based inheritance.
In fact, Go supports no form of inheritance.

After the initial excitement of C++, and the cold reality of inheritance in commercial C# and Java programming, Go's abandonment of inheritance appears prescient.
Not only did this side step the quagmire of multiple inheritance, it committed the language firmly to the paradigm of composition.

Does this mean then that Go programs do not, or can not, follow the SOLID design principals, or that Go is not an object oriented language?
Let us investigate.

== Single responsibility principal

Let's open with the single responsibility principal.

[quote, Robert C. Martin]
A class should have one, and only one, reason to change.

Why is it important that as a unit, a piece of code should have only one impetus for change?
Why should a programmer care about this level of taxonomy?
Because as distressing as the idea that your own code may change, it is far more distressing that code your code depends is changing under foot.

When your code does change, it should do so in response to a direct stimuli, it shouldn't be a victim of collateral damage.
Change can be compartmentalised, making its effects more focused, and as a result, limiting the blast radius.
Therefore, code that has fewer responsibilities has fewer reasons to change.

Two pieces of code that are highly sensitive to change in their counterpart are said to be tightly coupled.
Coupling is simply a word that describes two things moving together, a change in one induces a change in another

In electrical engineering, inductive coupling describes the change in current in one winding of a transformer inducing a voltage in the other.
In nature, trees bend in the wind because they are coupled to the motion of air moving across their branches.

Uncle Bob's imperative single responsibility principal is a derived from a much older observation by Tom DeMarco.
In his book __Structured Analysis and System Specification__footnote:[http://www.amazon.com/Structured-Analysis-System-Specification-DeMarco/dp/0138543801] DeMarco puts forward a description of software cohesion.

[quote, Tom DeMarco, Structured Analysis and System Specification]
____
Cohesion is a measure of the strength of the association of the elements inside a module.
A highly cohesive module is a collection of statements and data items that should be treated as a whole because they are so closely related.
Any attempt to divide them would only result in increased coupling and decreased reliability.
____

The word _cohesion_, in the context of software, is the property of describing pieces of code are naturally attracted to one another.
They stick together, like the poles of magnets, and so where one goes, the other follows.

=== The Go package model

To describe the units of change in a Go program, we start with the package model.

In Go all code lives inside a package, even the main function--which we call, not surprisingly, the main package.
In this package delineated world, the units of change are primarily those a externally visible to a package.

Go packages are composed of various elements; constants, variables, types, functions, and methods.
Each of these can be either public or private, and true to Go's focus on simplicity, a symbol is by default private unless its name starts with an upper case letter.

=== Package names

A well designed package starts with its name, which is both as a description of its purpose, and a name space for when it is referred to by another package.
----
package http

package bufio

package json
----
A package should not be named after its contents. These are all example of poor package names
----
package server

package private

package utils
----
The use of another package's symbols inside your own is accomplished by the `import` declaration, which establishes a source level relationship between two packages.

Once imported, the symbols of that package are always referred to with a prefix of the name of their containing package.
This makes it trivial to discern where a symbol is declared.

// example

=== McIlroy's revenge

No discussion of Go, or decoupled design in general, would be complete without mentioning Doug McIlroy.

In 1964 Doug McIlroy postulated about the power of pipes for composing programs.
This was five years before the first Unix was written mind you.

[quote, Doug McIlroy, Quarter Century of Unix (Salus et al.)]
____
This is the Unix philosophy: Write programs that do one thing and do it well.
Write programs to work together.
Write programs to handle text streams, because that is a universal interface.
____
McIlroyâ€™s observations became the foundation of the UNIX philosophy; small, sharp tools which combine to solve larger tasks.
Tasks which oftentimes were not envisioned by the original authors.

Go programs embody the spirit of the UNIX philosophy.
In effect each Go package is itself a self contained Go program, with access to the entire language.
Go programs are therefore composed, just like the UNIX shell, by combining packages together.

== Open / Closed principal

In is 1988 book, __Object-Oriented Software Construction__, Bertrand Meyer defined the Open / Closed principal.

[quote, Bertrand Meyer, Object-Oriented Software Construction]
Software entities should be open for extension, but closed for modification.

The open closed principal, as interpreted by SOLID, states that classes should be open for extension, but closed for modification.
Go does not have classes, however we do have structures, and methods on types. Here is an example
----
type A struct {
	v int
}

func (a *A) Value() int { return a.v }
----

The type `A` has a method `Value` which returns the contents of `v`.
This is a not a particularly useful piece of code.
----
type B A
----
We introduce a type `B` which shares the same underlying type as `A`.
Note that `B` does not extend `A`, nor is `B` derived from `A`.
Both `A` and `B` share the same underlying type, a structure with one integer field, `v`.
----
struct {
        v int
}
----
Sharing the same underlying type means that values of type `A` can be converted to type `B` other because ultimately they share the same layout in memory.
----
var a A
a.v = 99
var b = B(a)
fmt.Println(b.v) // 99
----
However, the method set of `B` is distinct from `A`. In fact, in this example it is empty.
----
var a A
a.v = 100
fmt.Println(a.Value()) // prints 100
var b B
b.v = 200
fmt.Println(b.Value()) // b.Value undefined (type B has no field or method Value)
----
If we want B to have access to A's methods, not just it's fields, we can instead do this.
----
Type A struct {
     v int
}

func (a A) Hello() {
	fmt.Println("Hello YOW!West %d", v)
}

Type B struct {
     A
}

func main() {
	var a A
	a.v = 2014
	var b B
	b.v = 2015

	a.Hello() 
	b.Hello()
}
----
In Go we call this practice _embedding_.
In this example type `B` has a `Hello` method because `A` has been embedded into `B`.

It is as if by embedding `A` into `B` the compiler had provided the following _forwarding_ method for us (which is not far from the truth).
----
func (b B) Hello() {
	b.A.Hello()
}
----
But embedding isn't just for methods, it also provides access to an embedded type's fields.
As you saw above, because both A and B are defined in the current package, we can access `A`'s private fields as if they were defined in `B`.

Embedding allows Go's types to be open for extension.

=== No virtual dispatch

A caller will see `B`'s methods overlaid on `A`'s because `A` is embedded, as a field, within `B`.

However `A` is unaware that it has been embedded into `B`, as such there is no mechanism for `B`'s methods to override `A`'s. 
----
type Cat struct {
	Name string
}

func (c Cat) Legs() int { return 4 }
func (c Cat) CountLegs() {
	fmt.Printf("I have %d legs\n", c.Legs())
}

type OctoCat struct {
	Cat
}

func (o OctoCat) Legs() int { return 8 }

func main() {
	var octo OctoCat
	fmt.Println(octo.Legs()) // 8
	octo.CountLegs() // 4
}
----
In this example we have a `Cat` type which can count its number of legs with the `Legs` method.
We embed this `Cat` type into a new type, an `OctoCat`, and decare that octocats have eight legs.

Though `OctoCat` defines it's own `Legs` method which returns 8, when the `CountLegs` method is invoked, it returns 4.

This is because `CountLegs` is defined on the `Cat` type, so it dispatches to `Cat`'s `Legs` method.
`Cat` has no knowledge of the type it has been embedded inside of, so its method set cannot be altered by embedding it.

Thus, Go's types are closed for modification.

=== This is not inheritance

This is a not a wacky way of implementing inheritance, there is no implicit _this_ parameter in Go.
The receiver is exactly what you pass into it, the first parameter of the function. 
And because functions are not polymorphic, `OctoCat`'s are not substitutable for regular `Cat`'s.

In truth, methods in Go are little more than syntactic sugar around a function with a predeclared formal parameter, the receiver. 
----
func (s *Speaker) SayHello(name string)
----
Is just syntactic sugar for
----
func Hello(s *Speaker, name string)
----
And this brings us to the next principal.

== Liskov substitution principal

Coined in 1988 by Barbara Lisvok during her keynote address to the ACM SIGPLAN conference, the Liskov substitution principal states, roughly, that two types are substitute if they exhibit behaviour such that the caller is unable to tell the difference.

In a class based language, this is commonly interpreted as a specification for an abstract base class with various concrete implementations.
But Go does not have classes, or inheritance, so substitution cannot be implemented in terms of an abstract class.

As we saw above, if you have a type
----
type B struct {
	A
}
----
And a function that takes an `A`
----
func update(a A)
----
You can, assuming the types are public, pass `B`'s `A` field to the `update` function.
----
var b B
upate(b.A)
----
The embedded `A` structure inside `B` is unaware of the fact it is part of a larger structure, just as values in memory are unaware of their neighbours.
But this isn't really substitution.

=== Interfaces and behaviour

Substitution in Go is the pervue of interfaces.

While Go's packaging system draws strongly from Modula-2, and it's successor Oberon, the design of Go's interfaces are likely influenced by Python's protocols, a legacy from the environment where Go was born. 

Types are not required to nominate, either by an `implements` declaration or by extending from an abstract type, that they implement a particular interface. 
In Go, _any type_ can implement an interface provided it has methods whose signature matches the interface declaration.

While it is not possible to modify a type from another package, at any time an interface may be defined, and if a type satisfies the interface, then automatically that type _is_ an implementation of the desired interface.
We say that in Go interfaces are satisfied implicitly, rather than explicitly, and this has a profound impact on how they are used in the language.

=== Small interfaces

Well designed interfaces are more likely to be small interfaces; the prevailing idiom is an interface contains only a single method.
It follows logically that small interfaces lead to simple implementations, because it is hard to do otherwise.
Leading to packages comprised of simple implementations connected by common behaviour.

A canonical example of small interfaces are found in the io package.
----
type Reader interface {
	Read(buf []byte) (int, error)
}

type Writer interface {
	Write(buf []byte) (int, error)
}

type Closer interface {
	Close() error
}
----

TODO SHOW MultiWriter, TeeReader, Limit Reader, etc
TODO show reader implementations, Brad's A reader, or bytes.Buffer

=== Interface composition

In Go, we often compose interfaces from smaller ones.
Just as we saw above, two types can be considered equal when they have the same set of fields, two interfaces are equal when they have the same set of methods.
----
type File interface {
	Read([]byte) (int, error)
	Write([]byte) (int, error)
	Close() error
}
----
Similar to type embedding, Go supports interface embedding, allowing the previous declaration to be rewritten as
----
type ReadWriter {
	io.Reader
	io.Writer
}

type ReadWriteCloser {
	ReadWriter
	io.Closer
}
----

=== Design by contract

Go does not have anything like Eifel's design by contract, but we do have interfaces.

[quote, Jim Weirich]
Require no more, promise no less

So the pull quote for LSP could be summarised by this lovely aphorism from Jim Weirich.
And this is a great segue into the next SOLID principal.

== Interface segregation principal

At this point in the presentation, hopefully you'll agree with me that in Go, types describing data, and interfaces describing behaviour.
Interfaces define the behaviour of various components, types provide the implementations.
As Go's interfaces are satisfied _implicitly_, it is not the implementation that dictates which interfaces it implements, that privilege belongs to the consumer.

[quote, Robert C. Martin]
Clients should not be forced to depend on methods they do not use.

The interface segregation principal says that clients should not be forced to depend on irrelevant parts of an interface.
When Martin talks about interfaces, he's making a broader definition than the one I just described in Go.

So if I was writing a function that wanted to work on file like things, I could specify it to take an `*os.File`, a type from the standard library that describes files, like this
----
func WriteUserConfig(f *os.File, cfg *Config) error
----
`WriteUserConfig` would be unpleasant to test, as I would have to ensure that `f` was written to a temporary location and always removed afterwards.
Because this function therefore only works with files on disk, to verify its operation, the test would have to read the contents of the file after being written.

`WriteUserConfig`'s signature precludes the option to write the user's config file to a network location, unless it was previously made available as a network share.
Assuming that network storage was to become requirement later, the signature of this function would have to change, impacting all its callers.

Additionally `*os.File` defines a lot of methods which are not relevant to `WriteUserConfig`.
Things like setting file permissions, reading directories.
It would be useful if the signature of the method could describe only the parts of `*os.File` that were relevant.

The `io` package provides an interface composed of the three basic io interfaces we say earlier:
----
package io

type ReadWriteCloser interface {
	Reader
	Writer
	Closer
}
----
Using `io.ReadWriteCloser` we can redefine `WriteUserConfig` in terms of an interface that described more general file shaped things.
----
func WriteUserConfig(f io.ReadWriteCloser, cfg *Config) error
----
With this change, any type that implements the `io.ReadWriteCloser` interface can be substituted for `*os.File`.
This makes `WriteUserConfig` both broader in its operation, and also clarifies both to the caller and author of `WriteUserConfig` which methods of the `*os.File` type are relevant to its operation.
However we can apply the interface segregation principal to improve the usability and testability of this function.

Firstly, it is unlikely that if `WriteUserConfig` follows the single responsibilty principal, it will read the file it just wrote to verify its contents--that is probably the role of another piece of code.
So we can narrow the specification for the interface to just writing and closing.
----
func WriteUserConfig(f io.WriteCloser, cfg *Config) error
----
We can improve this further.
By providing `WriteUserConfig` with a mechnism to close f this raises the question of under what circumstances will `f` be closed.
Possibly this will be unconditionally, or it could be only in the case of success.
This presents a problem for the caller of WUC as it may want to write additional data to `f` after the config is written.

On solution would be to define a new type which embeds f's io.Writer and provides a Close method which does nothing.
----
type NoCloseWriter struct {
	io.Writer
}

func (ncw NoCloseWriter) Close() error { return nil }

err := WriteUserConfig(NoCloseWriter{Writer: f}, cfg)
----
A better solution would be to redefine WriteUserConfig to take only an io.Writer, stripping it of the ability to do anything but write data to a stream.
----
func WriteUserConfig(f io.Writer, cfg *Config) error
----
By applying ISp to WriteUserConfig this function has become simlutaniously the most specific in its requirements, it only needs a thing that is writable, and the most generic in its function, it can write a config to anything which is writable.

Highly cohesive interface types have methods which are directly related to the operations -- towards a _single_ goal (SRP), 

=== Poor interface designs

Before moving to the final SOLID principal, I want to touch briefly on aspect of poor interface design.
You can spot poor interface declarations, they're usually the ones with a large number of methods.
The other sign is in many of those interface's implementations, methods will be stubbed out, and things will be just fine--in tests and in production.

You don't know why you need these methods, but you have to have them -- because that's what the interface's contract requires.
These are the bureaucracy of your interface.

An example of this comes from the net.Conn interface.
----
type Conn interface {
	io.ReadWriteCloser

	LocalAddr() net.Addr
	RemoteAddr() net.Addr

	SetDeadline(t time.Time) error
	SetReadDeadline(t time.Time) error	
	SetWriteDeadline(t time.Time) error	
}
----
net.Conn conceptually extends an io.Reader/Writer/Closer with methods for retrieving the local and remote addresses for this network connection, and because this type deals with actors over a network, setting deadlines.

Show the net.Conn interface as an example of both a good, and bad design.

== Dependency inversion principal

The final SOLID principal is the dependency inversion principal.

[quote, Robert C. Martin]
Depend on abstractions, not on concretions.

This is the dependency inversion principal, not dependency injection, or worse, a dependency injection _framework_.
This is also not inversion of control; although this was part of the original paper.
Fortunately the industry has abandoned the notion of this kind of meta-programming.

What is a concretion, and how does it invert one's dependencies.
What does dependency inversion mean in practice for Go programmers?

In the previous example we saw a function defined in terms of an interface defined in another package.
----
package p

import "io"

func WriteUserConfig(f io.Writer, cfg *Config) error
----

As Go supports both functions and methods on types, you can implement not just singleton's, but plan old functions.
A function is a constant who's value is the entry point to the function.
As it's a constant, obviously it cannot be changed, and that shows itself often when writing tests.

Go does not have constructors.
Instead we encourage Go programmers to make use of the type's zero value; that is, the interpretation of the type's fields if the memory that underlies them were zero.

But it is com

Clients, functions and methods that take values, should depend on interface types, and those interfaces should be as narrow as possible.
This reduces, possibly eliminates, their coupling to the concrete implementation they are provided at run time.

A public function in a commonly used package is a very tight source level dependency.

=== Pure functions

One obvious difference from Go's __everything is an object__ predecessors is it's support for first class functions and lexical closures.

Go functions are not pure, not in a functional programming sense of the world, but you should act as if they are anyway.
Eschew global state, pass all the values required into the function.

=== Implicit interfaces

So far we've discussed that methods and functions should operate on parameters declared as interface types.
This decouples the consumer from the implementation details of the value it is passed and allowing the user of those methods to reuse the functionality of that code by substituting many implementations.

A great example of this is the `Io.Copy` method from the `io` package.
----
func Copy(w io.Writer, r io.Reader) (int, error)
----
`Copy` reads from a reader until it is exhausted, and writes that data to a writer.
When complete it returns the number of bytes transferred, and if the transfer ended normally, or abnormally.

Packages should interact using interface values, rarely concrete types.
Those interface values can be defined by the caller, or the callee.

// Show Weirich's diagram of A, B, C, D pointing to E

A change to this

- talk about how interfaces are satisfied implicitly, at compile time.
-- Talk about interface equality, and that the consumer of a type defines the interface it expects. 
-- This breaks the source level dependency on the _interface_.
-- Talk about implicit interfaces
- talk about how interfaces can be defined by the caller
-- Bonus: in Go, interface's are implemented implicitly. Which means you no longer need to import a package to ensure you share the same interface definition. In Go, interfaces types are equal if their method sets are equal, and as we saw earlier one can define a smaller interface (fewer methods)

Give example from http class that takes bufio.Reader, talks about how that limits us.

You want to depend on things that cannot change, and those are the _interfaces_ not the implementation -- because software changes, that is it's nature

== A theme

Each of Martin's SOLID principals are powerful ideas in their own right, but taken together they have a central theme; dependency management.

Martin's observation is all five of the SOLID principals relate to managing the dependency between software units.
The dependencies between functions, the dependencies between types, the dependencies between modules.
This is another way of saying "decoupling", which is indeed the goal, because software that is loosely coupled is software that is easier to change.

SRP encourages you to 

OCP encourages you to compose types with embedding rather than extend them through inheritance.

LSP encourages you to describe the dependencies between your packages in terms of interfaces, not concrete types.
How can we be confident that any implementation will work?
By making the interface smaller.

ISP takes that idea further and encourages you to define functions and methods that depend only on the behaviour that they need to function.
If your type only needs to implement a single interface method, then it is more likely to have only one responsibility.

DIP encourages you to reduce the number things your code expects from the source level--in Go we see this with a reduction in the number of `import` statements--to runtime. This is crucial because if the code is written to expect _anything_ that implements a certain interface, a certain behaviour--behaviour that the code defines--not imports from somewhere else.

This is ISP, and in Go the strong drive is to create interfaces that expose only a single behaviour.


Go was explicitly built to control source level dependencies.

== In Closing

[quote,Sandi Metz]
Design is the art of arranging code that needs to work _today_, and to be easy to change _forever_.

If you were to summarise this talk as an elevator pitch it would probably be; interfaces let you apply SOLID principals to Go programs.
Interfaces in Go are a unifying force; they are _the_ means of describing behaviour.

Interfaces let programmers describe what their function, method, or package provides--not how it does it.
This shouldn't really be a surprise, as Go's interfaces provide the language with polymorphic dispatch, which really is the core of object orientation.

Thank you.

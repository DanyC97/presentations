= Do not fear first class functions
Dave Cheney <dave@cheney.net>
v1.0, 10th Oct, 2016

== Introduction

Roughly two years ago I stood on a stage not unlike this one this and told you about my opinions for how configuration options should be handeld in Go.
The cornerstone of this presentation was Rob Pike's _Self referential functions_ https://commandcenter.blogspot.com.au/2014/01/self-referential-functions-and-design.html[blog post].

In the past two years it has been wonderful to watch the idea mature from Rob's original blog post, to my presentation, to the gRPC project, who have continued to evolve this design pattern into what I consider to be its best form so far.

But, a few months ago, when I was talking to Gophers at a conference in London, several of them noted independently that while _they_ understood the notion of a function that _returns_ a function they were worried that other Go programmers, insinuating that possibly less experienced programmers, would not be able to understand this style of programming.

So I'm here today to tell you, and show you, that you do not need to fear first class functions.

== Recap

To begin, I'll very quickly recap the functional options pattern
----
include::do-not-fear-first-class-functions/options.go[]
----
We start with some options, expressed as functions which take a pointer to a `Config` structure, we pass those functions to some constructor type function, in this case called `NewTerrain`, and inside the body of that function each option function is invoked in order, passing in a reference to its `Config` value.

Ok, everyone should be familar with this pattern.

Where the concern came was an option function that took some parameters.
----
func WithCities(n int) func(*Config) { ... }

func main() {
        t := NewTerrain(WithCities(9))
        ...
}
----
In this example we have a `WithCities` option, which lets us add a number of cities to the terrain model.
Because `WithCities` takes an argument, we cannot simply pass `WithCities` to `NewTerrain` as the signature does not match.
Instead we evaluate `WithCities`, passing in the number of cities to create, and use the _result_ of this function as the value to pass to `NewTerrain`.

== First Class functions

So, what's going on here?
Let's break it down.

Evaluating a function returns a value.
----
package math

func Min(a, b float64) float64
----
We have functions that take two numbers and return a number
----
package bytes

func NewReader(b []byte) *Reader
----
We have functions that take a slice, and return a pointer to a structure.
----
func WithCities(n int) func(*Config)
----
We now have a function which returns a function.
The type of the function that is returned from `Cities` is a function which takes a pointer to a `Config`.

== interface.Apply

Perhaps another way to think about what is going on here is rewrite the functional option pattern using an interface.
----
type Option interface {
	Apply(*Config)
}

func NewTerrain(opts ...Option) *Terrain {
        var config Config
        for _, opt := range opts {
                opt.Apply(&c)
        }
        ...
}
----
Rather than using a function type, we declare an interface, we'll call it `Option` with a single method, called `Apply`.
Whenever we call `NewTerrain` we pass one or more values that implement the `Option` interface.
Inside `NewTerrain`, just as before, we loop over the slice of options and call their `Apply` method.
Hopefully everyone is comfortable with this pattern.

Ok, so this doesn't look too different to the first example, rather than ranging over a slice of functions and calling them, we range over a slice of interface values and call a method on each.
Let's take a look at the other side, declaring an option.
----
type reticulatedSplines struct {}

func (r *reticulatedSplines) Apply(c *Config) { ... }

func WithReticulatedSplines() Option {
	return new(reticulatedSplines)
}
----
You'll immediately see that there is more code.
Because we're passing around interface values, we need to declare a type to hold the `Apply` method.
We also need to declare a _constructor_ function to create the `reticulatedSplines` option.
----
type cities struct {
	cities int
}

func (c *cities) Apply(c *Config) { ... }

func WithCities(n int) Option {
	return &cities{
		cities: n,
	}
}
----
Now to write `WithCities` using our `Option` interface we need to do a bit more work because in the functional version the value of `n`, the number of cities to create, was lexically captured -- this is why first class functions are also known as _closures_ -- for us.

In out `Option` interface version, we need to declare

we need to record the number of cities to create.
To do this 

Interfaces are important when you want to explicitly bind behaviour and 	

== Function / Interface duality

In 2015 Tomas Senart spoke about the duality of the a single method interface and a first class function. 
You can see this play out in these examples; they are _functionaly_ equvilent, an interface with one method, and a function are interchangable.
----
func WithCities(n int) func(*Config) {
	option := &cities{
		cities: n,
	}
	return option.Apply
}
----
We can take an interface value and return a single method as a function.
----
type option struct {
	fn func(*Config)
}

func (o *option) Apply(c *Config) {
	o.fn(c)
}

func ReticulatedSplines(c *Config) { ... } 

func WithReticulatedSplines() Option {
	return &option {
		fn: ReticulatedSplines,
	}
}
----
And we can take a function and construct a value which implements a particular interface.

So, for single functions and single method interfaces, they are comparable.
But, surely you can see that dealing with functions as a first class citizen is more striaght forward.

== Encapsulating Behaviour

Ok, let's leave interfaces for a moment and talk about some other properties of first class functions.

Usually, when we invoke functions, or methods, we do so by passing around data. 
The job of the function is to _interpret_ that data and take some action.

Passing around function values, allows you to pass behaviour to be executed, rather that data to be interpreted.
In effect, passing a function value allows you to declare code that will execute later.  

To illustrate this, let's look at some examples.

=== Calculator

----
include::do-not-fear-first-class-functions/calc.go[]
----
Here is a simple calculator type.
It has one method, +Do+, which takes an operation and an operand, `v`.

Our calculator knows how to add, subtract, and multiply.
If we wanted to implement division, we'd have to allocate a operation constant, then open up the code for Do and add the division operation.
And what if we wanted to add square root, or exponentiation?

Each time we do this, `Do` grows longer, gets harder to follow.
Each time we do this, we have to encode into the `Do` method knowledge of how to _interpret_ each operation.

Let's rewrite our calculator a little
----
type Calculator struct 
	acc float64
}

func (c *Calculator) Do(op func(float64, float64) float64, v float64) float64 {
	c.acc = op(c.acc, v)
	return c.acc
}
----
Ok, this signature is quite intimidating, so let's break it down.

- As before we have a `Calculator`, which manages it's own accumulator.
- The `Calculator` has a Do method, which this time takes an function as the operation, and a value as the operand.
- The type of `op` is a function which takes two float64's and returns a third.
- The valye of `v` is simply a float64.

Whenever `Do` is called, it invokes the operation provided passing in both it's accumuator and the value of v.

So, how do we use this new `Calculator` in practice?
----
func Add(a, b float64) float64 {
	return a + b
}

func main() {
	var c Calculator
	fmt.Println(c.Do(Add, 100))	// 100
	fmt.Println(c.Do(Add, 200))	// 300
}
----
What's happening here?
We construct a calculator, then call it, passing the `Add` operation.
`c.Do` calls the operation we pass in, using the accumulator and the operand we provide.

What about the other operations?
----
func Sub(a, b float64) float64 {
	return a - b
}

func Mul(a, b float64) float64 {
	return a * b
}

func main() {
	var c Calculator
	c.Do(Add, 5)
	c.Do(Sub, 3)
	fmt.Println(c.Do(Mul, 8)) 	// 16
}
----
It turns out they aren't too hard either.

Ok, how can we extend our calculator to other operations like squareroot?

----
func Srqt(n, _ float64) float64 {
	return math.Sqrt(n)
}

func Main() {
	var c Calculator
	c.Do(Add, 16)
	c.Do(Sqrt, 0) // operand ignored
}
----
It turns out there is a problem.
Square root take one argument, not two. 
But our calculator requires an operation that has two arguments.

Maybe we just cheat and ignore the operand.
That's a bit gross, can we do better?
I think we can.
----
func Add(n float64) func(float64) float64 {
	return func(acc float64) flaot64 {
		return acc + n
	}
}

func (c *Calculator) Do(op func(float64) float64) float64 {
	c.acc = op(c.acc)
	return c.acc
}

func main() {
	var c Calculator 
	c.Do(Add(10))
	c.Do(Add(20)) 	// 30
}
----
Let's redefine Add from a function that is called with two values and returns the sum, to a function which _returns_ a function that takes a value and returns a value.

Now we call `calc.Do` with a the _result_ of evaluating `Add(10)`, which is a function which takes a value, our calculators accumulator, and returns 10 more than the value.

Subtraction and multiplication are similarly easy to implement.
----
func Sub(n float64) func(float64) float64 {
	return func(acc float64) float64 {
		return acc - n
	}
}

func Mul(n float64) func(float64) float64 {
	return func(acc float64) float64 {
		return acc * n
	}
}
----	
But what about squareroot?
Now that our calculator operates on functions which take and return a single value, we 
----
func Sqrt() func(float64) float64 {
	return func(n float64) float64 {
		return math.Sqrt(n)
	}
}

func main() {
        var c Calculator
        c.Do(Add(2))
        c.Do(Sqrt)   // 1.41421356237
}
----
Hopefully you also noticed that the signature of our `Sqrt` function is the same as `math.Sqrt`, so we can make this code smaller by _resuing_ any function from the `math` package, not just `Sqrt`
----

func main() {
        var c Calculator
        c.Do(Add(2))
        c.Do(math.Sqrt)   // 1.41421356237
	c.Do(math.Cos)    // 0.99969539804
}
----
So, what does this example show?
We started with a model of hard coded, interpreted logic, moved to a functional model, where we pass in the behaviour we want, then by taking it a step further generalised it to work for operations with an unknown number of arguments.

=== Actor model

Let's change tracks a little and talk about why most of us are here at a Go conference; concurrency.
And to give due credit, the examples here are inspired by Bryan Boreham's talk from GolangUK.

Suppose we're building a chat server, we plan to be the next Hipchat or Slack, but we'll start small for the moment.
----
include::do-not-fear-first-class-functions/mutex.go[]
----
Here's the first cut of the heart of any chat system.
We have a way to register new connections, remove old ones, and send a message to all the registered connections.
And because this is a server, all of these methods may be called concurrently so we need to use a `sync.Mutex` to protect the `conns` map and prevent data races.

Is this what you'd call idiomatic Go code?
Maybe?

[quote, Rob Pike]
Don't communicate by sharing memory, share memory by communcating

Our first proverb.
Don't mediate access to shared memory with locks and mutexes, instead communicate by sharing memory.

So let's apply this advice to our chat server.
----
include::do-not-fear-first-class-functions/channels.go[]
----
Rather than using a mutex to serialise access to the ++Mux++'s `conns` map, we can give that job to a goroutine, and communicate with the goroutine via channels.

Hopefully this pattern is familar to some of you. Maybe you've written code like this.

Rather than using a mutex to serialise access to the `conn` map, `loop` will wait until it receives an operation, in the form of a value sent over a channel, on one of the `add`, `remove`, or `sendMsg` channels.
We don't need a mutex any more, because the the shared state, the `conn` map is now only mutated inside the `loop` function.

We can even make even stronger guarentees because we know that at any time, the goroutine running `loop` will be in one of four states

- waiting for a channel to become ready.
- adding to the conns map.
- removing from the conns map.
- iterating over the conns map to send a message to all clients.

It _cannot_ be mutated outside the `loop` function, even by code in the same package.
And if `loop` exits, we can throw away the conn map because there is noone left to listen to those channels

But, there's still a lot of hard coded logic here.
`loop` only knows how to do three things; add, remove and broadcast a message.
As with the `Calculator` example above, adding new features to our `Mux` type will involve creating a channel, adding a helper to send the data over the channel, and extending the `select` logic inside `loop` to process that message.

So, just like our previous `Calculator` we can rewrite our `Mux` to use first class functions to pass around behaviour to be executed, not dead data to be interpreted.
----
include::do-not-fear-first-class-functions/actor.go[]
----
Let's look at what has changed.

Previously each of the methods on `Mux` would send data over their respective channel to be _interpreted_ by `loop`.
Now, each method sends the _operation_ to be executed over a single channel to loop.

In this case the signature of the operation is a function which takes a map of `net.Addr`'s to `net.Conn`'s.
In a real program 

But there are a few problems still to fix.
The most pressing is the lack of error handling in `SendMsg`; an error writing to a connection will not be communicated back to the caller.
----
include::do-not-fear-first-class-functions/actor-ii.go[]
----
If you look closely

----
include::do-not-fear-first-class-functions/actor-iii.go[]
----

- where's the locking? Not needed, becauce the function we pass, the behaviour, is executed _in the context_ of the caller.

== One more thing

Hopefully by now I've convinced you of the power of first class functions.

First class functions aren't new or novel, many historical languges have offered them, even C, and in fact it was only somewhere along the lines of removing pointers did programmers in the Java stream of the language tree loose access to first class functions.

And true to Go's orthogonality, first class functions, just like any type, can have methods attached to them, and this allows us to do amazing things.

----
include::do-not-fear-first-class-functions/maps.go[]
----

== Conclusion

FCF are somethign we all need to know about at use

FCF aren't unique to Go, but they bring us tremendous expressive power

FCF aren't somethign to be afraid of, they're a tool we should all have in our toolkit

FCF, like the other powerful features Go offers, should be used with restraint; just as it is possible to make an overcomplicated program with the overuse of channels, it's possible to make an impenetrable program with an overuse of FCFs. But that does not mean you shouldn't use them at all just use them in moderation.

first class functions are very powerful, but, if you consider the fundamentals that go is built on, -- everything is a value -- then they shouldn't be foreign to you

fcf's let you pass around _behaviour_, not just dumb data that must be _interpreted_.

fcf's aren't new or novel, many historical languges have offered them, even C, and in fact it was only somewhere along the lines of removing pointers did programmers in the Java stream of the language tree loose access to first class functions

our contemporaries, like javascript, rust, python? have access to this feature

and finally, as you saw, Go's functions, just like any other type, can have their own methods, and this allows us to do amazing things.

go programmers shouldn't be afraid of first class functions

If you can learn to use pointers, you can learn to use first class functions.
They aren't hard, just a little unfamiliar, and unfamiliarity is something that can be overcome with exposure.

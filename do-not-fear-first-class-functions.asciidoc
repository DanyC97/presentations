= Do not fear first class functions
Dave Cheney <dave@cheney.net>
v1.0, 10th Oct, 2016

== Introduction

Roughly two years ago I stood on a stage not unlike this one this morning and told you about my opinions for how configuration options should be handeld in Go.
The cornerstone of this presentation was Rob Pike's _Self referentiontion functions_ https://commandcenter.blogspot.com.au/2014/01/self-referential-functions-and-design.html[blog post].

In the past two years it's been wonderful to watch the idea mature from Rob's original blog post, to my presentation, to the gRPC project, who have continued to evolve this design pattern into what I consider to be its best form so far.

But, a few months ago, when I was talking to Gophers at a conference in London, several of them noted, independently, that while _they_ understood the notion of a function that returns a function they were worried that other Go programmers, insinuating that possibly less experienced Go programmers would not be able to understand this style of programming.

So I'm here today to tell you, and show you, that you don't need to fear first class functions.

== Recap

Before I being, I'll very quickly recap the functional options pattern

____
func WithReticulatedSplines(c *Config) { ... }

func NewTerrain(opts ...func(*Config)) {
	var config Config
	for _, fn := range opts {
		fn(&c)
	}
 	...
}

func main() {
      t := NewTerrain(WithReticulatedSplines)
}
____

We start with some options, expressed as functions which take a pointer to a `Config` structure, we pass those functions to some constructure type functiontion, in this case called NewTerrain, and inside the body of that function each option function is invoked in order, passing in a reference to some Config object.

Ok, everyone should be familar with this pattern.

Where the concern came was an option function that took some parameters.
____
func WithCities(n int) func(*Config) { ... }

func main() {
     t := NewTerrain(WithCities(9))
____
In this example we have a WithCities option, which lets us add a number of cities to the terrain model

== First Class functions

So, what's going on here?
We now have a function which returns a function

== interface.Apply

== Encapsulating Behaviour

show how passing around functions allows you to pass behaviour to
be executed, rather that data to be interpreted

Passing functions allows you to declare code that will execute later. 

Func() isn't that special, because the only context it captures is the one it was created with. 

But passing a function that takes an argument allows you to join the dots. 

Show func/interface duality earlier, then show the method Arg func(context) duality. 

=== Calculator

Show a calcualtor that works on operations, 

=== Actor model

Show the actor model replacing a fan in of channels


== Taking it further

== Impure functions

Is what we've been doing for the past 15 minutes functional programming?
Not really/Sorta/No/It depends

== What's in a name

(if time) talk about how avoiding _naming_ a function gives you
more flexibility

- quote "knowing something's true name gives you the power over it"

coupling, if you give something a name, then everyone has to agree on the name, and you agree on the name by everyone importing the package that the name is defined in.

This creates a strong source code coupling

A function value is equal only to itself, and nil

But a function value can be assigned to any variable of an equal type. 

== Closures

We cannot talk about first class functions without talking about closures, which is where they get a common nickname.

the scope of the function closes over the variables in its scope. What is this? well, it can be quite a lot.

FCF are somethign we all need to know about at use

FCF aren't unique to Go, but they bring us tremendous expressive power

FCF aren't somethign to be afraid of, they're a tool we should all have in our toolkit

FCF, like the other powerful features Go offers, should be used with restraint; just as it is possible to make an overcomplicated program with the overuse of channels, it's possible to make an impenetrable program with an overuse of FCFs. But that does not mean you shouldn't use them at all just use them in moderation.

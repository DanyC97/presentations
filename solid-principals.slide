The SOLID Principals of Go
YOW!West
3 May 2016

Dave Cheney
dave@cheney.net
http://dave.cheney.net/
@davecheney

* Thank you

Thank you to tenntenn

Thank you to Japanese Gophers.

* Introduction

[ image, book: Practical go ]

i want to start this talk with a little background. over the last few years I've been collecting notes on topics to write about on my blog, things to speak about, ideas from talking with friends, online, etc.

originally i wanted to write them up as blog posts, but quickly i realised that I had so many it would be a huge undertaking. so

[ show picture o effecive c++ ]

i thought about writing a book, and before you get to excited, no, i haven't written a book, and that is for all the usual reasons. But more profoundly, i havne't written a book because I was never able to develop the theme that I wanted

So, what was the theme that I failed to discover. well, as many travellers will tell you,  you should travel the world with your eyes open -- surely a good safety tip -- but what they really mean is, when you travel the world, be open to the ideas and expereinces you will ahve along the way, don't let your preconditions color your interpretations, don't got out into the world decidin gthat you already know all the answers.

So, what was my precondition when I tried to write this book ? What had I decided was the truth, and I just needed to find evidence of that. 

In a word rules.

It is so common, as programmers for us to ask quetions like

what is the _right_ way to do something

When should I do X, and when should I do Y

A Go programmers, when should I use and interface, when should I use a concrete type

When should I use a function and when should I use a method

When shoudl I declare a method on a pointer, when should I declare a method on a value

What is the right way to handle errors.

And looking at my stack of notes I said to myself

"I think I can answer these questions, I'm going to write a book with the answers for Go programmers to these questions"

And I felt that it must be possible. I mean if Scott Meyers can write books about this for C++, Go, a much simpler langauge should be easy -- right ?

And to make a long story short, after months of writing and thinking and talking to people I realise that I had made a mistake.

And that mistake was, there are no rules that i can give to explain how I think GO programs should best be written.

In fact, the only rule I could come up with, after months of writing was 

"It depends"

And it depends is something that as an engineer I say a lot, maybe you do as well.

David, what's the best way to handle uploads to our application

Well, it depends,

[ and so on ]

And it's not that I'm being difficult, or non comittal, the it depends is always a prelude to asking questions about how they want to _use_ the thing that they have asked me to build.

And this here is the _essence_ of design. Design is about creating a solution that works without the constraints of the environment which it will be used.

Here in Tokyo for example I've seen a lot of these 

[ picture, tiny car ]

So, why are these popular here ? Why did someone design a car so specific for Tokyo ? 

One answer is tokyo is very crowded city, small lanes, space is at a premium, so if you design a car with a smaller footprint, it will be easier to drive in Tokyo and easier to park.

So, coming back to It Depends.

What I realised working on this book is it is going to be difficult to come up with a set of rules that you can apply  to writing GO programs. And the clue there is really in the word

rules / patterns /  laws

these are all very concrete ideas, everyone must follow the rules, everyone must obey the law, you _should_ use this pattern when designing your software. IN fact, we have books giving 50 patterns that you can use.

But what I realised in the end is that the reader of this book is not looking for rules, or patterns, but advice. 



* Dependency  inversion

Depend on abstractions, do not depend on cocretions

To avoid dependencies your code should be

Loosely coupled
Highly cohesive
Easily composable
Context independent

* Single responsibility principal

Single responsibility principal == single interface method

* Decoupling

Martin's SOLID principals are each powerful ideas in their own right, but taken together they have a central theme.

Reduce source level dependencies.

Which is a more straight forward way of saying "decoupling"

* Source level dependencies vs run time dependencies

So if the big picture is 

If you must, think of this as the old programmer's saw; adding a level of indirection. 

* Rules vs. Principals

Stop talking about rules for software development, talk about principals.

Be true to your principals, but flexible, it's ok to bend once in a while, but don't abandon them.

https://twitter.com/2xb/status/705091931982929920

Rules do not need a context, it doesn't matter how important it is to you, wooden bridges are not as strong as steel ones

Principals need a context. 

* Being opinionated

The go compiler has principals, we call it being opinionated.

No warnigns
No flags to control optimisation
No unused variables
No unused imports
...etc

* depend on abstractions not concretions

you want to depend on things that cannot change, and those are the _interfaces_ not the implementation -- because software changes, that is it's nature

* TL;DR

se interfaces,

don't just declare them

but design your program around them

BUT - and this is crucial, do not _substitute_ interfaces for concrete tyoes, do not creat the interface so you can mock the concrete type, use and interface to _describe_ the behaviour, describe the contract between two compoents

and, if you do it right, those interfaces will be small

and when I say small, i mean one method, because each type should have only a single responsibility -- a singe purpose -- a single behavoiur

* In conclusion

So the TL;DR of this talk, is interfaces let you apply SOLID principals to Go programs, and apply them well.

And this shouldn't really be a suprise, because interfaces provide polymorphic dispatch, which is really the core of OO; albeit most classical OO langauges implement polymorphic dispatch via inheretence and abstract methods.

but there is more

http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod

Rules for architecture, track layout, design rules, building a bridge, rules, because we know the tensile strength of steel

Principals, because they guide us in our lives

Be kind
Be humble

That sort of thing

So if we move away from rules [ gang of four book ]

How can we talk about good software design

Well, just like you have principals for how to live a knoble life, there are principals of software design. Solid principals

---

Thanks Bill. The TL;DR for 4 out of the 5 (and probably actually 5 out
of 5) is "use interfaces", like I said last year in NYC I think the
way interfaces are implemented in Go is going to be one of its
defining traits in years to come.

New languages won't be complete unless they come with a gofmt, some
kind of concurrency story, and an approach to composition that looks a
lot like go's interfaces, not abstract class hierarchies.
